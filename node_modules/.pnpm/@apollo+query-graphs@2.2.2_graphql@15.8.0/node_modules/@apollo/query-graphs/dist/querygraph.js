"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simpleTraversal = exports.buildFederatedQueryGraph = exports.buildSupergraphAPIQueryGraph = exports.buildQueryGraph = exports.QueryGraphState = exports.QueryGraph = exports.Edge = exports.isRootVertex = exports.RootVertex = exports.Vertex = exports.isFederatedGraphRootType = exports.federatedGraphRootTypeName = exports.FEDERATED_GRAPH_ROOT_SOURCE = void 0;
const federation_internals_1 = require("@apollo/federation-internals");
const util_1 = require("util");
const transition_1 = require("./transition");
const nonTrivialEdgePrecomputing_1 = require("./nonTrivialEdgePrecomputing");
exports.FEDERATED_GRAPH_ROOT_SOURCE = federation_internals_1.FEDERATION_RESERVED_SUBGRAPH_NAME;
const FEDERATED_GRAPH_ROOT_SCHEMA = new federation_internals_1.Schema();
function federatedGraphRootTypeName(rootKind) {
    return `[${rootKind}]`;
}
exports.federatedGraphRootTypeName = federatedGraphRootTypeName;
function isFederatedGraphRootType(type) {
    return type.name.startsWith('[') && type.name.endsWith(']');
}
exports.isFederatedGraphRootType = isFederatedGraphRootType;
class Vertex {
    constructor(index, type, source) {
        this.index = index;
        this.type = type;
        this.source = source;
    }
    toString() {
        return `${this.type}(${this.source})`;
    }
}
exports.Vertex = Vertex;
class RootVertex extends Vertex {
    constructor(rootKind, index, type, source) {
        super(index, type, source);
        this.rootKind = rootKind;
    }
    toString() {
        return super.toString() + '*';
    }
}
exports.RootVertex = RootVertex;
function toRootVertex(vertex, rootKind) {
    return new RootVertex(rootKind, vertex.index, vertex.type, vertex.source);
}
function isRootVertex(vertex) {
    return vertex instanceof RootVertex;
}
exports.isRootVertex = isRootVertex;
class Edge {
    constructor(index, head, tail, transition, conditions) {
        var _a;
        this.index = index;
        this.head = head;
        this.tail = tail;
        this.transition = transition;
        this._conditions = (_a = conditions === null || conditions === void 0 ? void 0 : conditions.clone()) === null || _a === void 0 ? void 0 : _a.freeze();
    }
    get conditions() {
        return this._conditions;
    }
    isEdgeForField(name) {
        return this.transition.kind === 'FieldCollection' && this.transition.definition.name === name;
    }
    matchesSupergraphTransition(otherTransition) {
        (0, federation_internals_1.assert)(otherTransition.collectOperationElements, "Supergraphs shouldn't have transition that don't collect elements");
        const transition = this.transition;
        switch (transition.kind) {
            case 'FieldCollection': return otherTransition.kind === 'FieldCollection' && transition.definition.name === otherTransition.definition.name;
            case 'DownCast': return otherTransition.kind === 'DownCast' && transition.castedType.name === otherTransition.castedType.name;
            default: return false;
        }
    }
    label() {
        if (this.transition instanceof transition_1.SubgraphEnteringTransition && !this._conditions) {
            return "";
        }
        return this._conditions ? `${this._conditions} âŠ¢ ${this.transition}` : this.transition.toString();
    }
    withNewHead(newHead) {
        return new Edge(this.index, newHead, this.tail, this.transition, this._conditions);
    }
    addToConditions(newConditions) {
        this._conditions = this._conditions
            ? this._conditions.clone()
            : new federation_internals_1.SelectionSet(this.head.type);
        this._conditions.mergeIn(newConditions);
        this._conditions.freeze();
    }
    isKeyOrRootTypeEdgeToSelf() {
        return this.head === this.tail && (this.transition.kind === 'KeyResolution' || this.transition.kind === 'RootTypeResolution');
    }
    toString() {
        return `${this.head} -> ${this.tail} (${this.label()})`;
    }
}
exports.Edge = Edge;
class QueryGraph {
    constructor(name, vertices, adjacencies, typesToVertices, rootVertices, sources) {
        this.name = name;
        this.vertices = vertices;
        this.adjacencies = adjacencies;
        this.typesToVertices = typesToVertices;
        this.rootVertices = rootVertices;
        this.sources = sources;
        this.nonTrivialFollowupEdges = (0, nonTrivialEdgePrecomputing_1.preComputeNonTrivialFollowupEdges)(this);
    }
    verticesCount() {
        return this.vertices.length;
    }
    edgesCount() {
        return this.adjacencies.reduce((acc, v) => acc + v.length, 0);
    }
    rootKinds() {
        return this.rootVertices.keys();
    }
    roots() {
        return this.rootVertices.values();
    }
    root(kind) {
        return this.rootVertices.get(kind);
    }
    outEdges(vertex, includeKeyAndRootTypeEdgesToSelf = false) {
        const allEdges = this.adjacencies[vertex.index];
        return includeKeyAndRootTypeEdgesToSelf ? allEdges : allEdges.filter((e) => !e.isKeyOrRootTypeEdgeToSelf());
    }
    outEdgesCount(vertex) {
        return this.adjacencies[vertex.index].length;
    }
    outEdge(vertex, edgeIndex) {
        return this.adjacencies[vertex.index][edgeIndex];
    }
    isTerminal(vertex) {
        return this.outEdgesCount(vertex) === 0;
    }
    verticesForType(typeName) {
        const indexes = this.typesToVertices.get(typeName);
        return indexes == undefined ? [] : indexes.map(i => this.vertices[i]);
    }
}
exports.QueryGraph = QueryGraph;
class QueryGraphState {
    constructor(graph) {
        this.graph = graph;
        this.verticesStates = new Array(graph.verticesCount());
        this.adjacenciesStates = new Array(graph.verticesCount());
    }
    setVertexState(vertex, state) {
        this.verticesStates[vertex.index] = state;
    }
    removeVertexState(vertex) {
        this.verticesStates[vertex.index] = undefined;
    }
    getVertexState(vertex) {
        return this.verticesStates[vertex.index];
    }
    setEdgeState(edge, state) {
        if (!this.adjacenciesStates[edge.head.index]) {
            this.adjacenciesStates[edge.head.index] = new Array(this.graph.outEdgesCount(edge.head));
        }
        this.adjacenciesStates[edge.head.index][edge.index] = state;
    }
    removeEdgeState(edge) {
        this.adjacenciesStates[edge.head.index][edge.index] = undefined;
    }
    getEdgeState(edge) {
        const forEdge = this.adjacenciesStates[edge.head.index];
        return forEdge ? forEdge[edge.index] : undefined;
    }
    toDebugString(vertexMapper, edgeMapper) {
        const vs = this.verticesStates.map((state, idx) => ` ${idx}: ${!state ? "<null>" : vertexMapper(state)}`).join("\n");
        const es = this.adjacenciesStates.map((adj, vIdx) => adj.map((state, eIdx) => ` ${vIdx}[${eIdx}]: ${!state ? "<null>" : edgeMapper(state)}`).join("\n")).join("\n");
        return `vertices = {${vs}\n}, edges = {${es}\n}`;
    }
}
exports.QueryGraphState = QueryGraphState;
function buildQueryGraph(name, schema) {
    return buildGraphInternal(name, schema, false);
}
exports.buildQueryGraph = buildQueryGraph;
function buildGraphInternal(name, schema, addAdditionalAbstractTypeEdges, supergraphSchema) {
    const builder = new GraphBuilderFromSchema(name, schema, supergraphSchema ? { apiSchema: supergraphSchema.toAPISchema(), isFed1: (0, federation_internals_1.isFed1Supergraph)(supergraphSchema) } : undefined);
    for (const rootType of schema.schemaDefinition.roots()) {
        builder.addRecursivelyFromRoot(rootType.rootKind, rootType.type);
    }
    if (addAdditionalAbstractTypeEdges) {
        builder.addAdditionalAbstractTypeEdges();
    }
    return builder.build();
}
function buildSupergraphAPIQueryGraph(supergraph) {
    return buildQueryGraph("supergraph", supergraph.toAPISchema());
}
exports.buildSupergraphAPIQueryGraph = buildSupergraphAPIQueryGraph;
function buildFederatedQueryGraph(supergraph, forQueryPlanning) {
    const subgraphs = (0, federation_internals_1.extractSubgraphsFromSupergraph)(supergraph);
    const graphs = [];
    for (const subgraph of subgraphs) {
        graphs.push(buildGraphInternal(subgraph.name, subgraph.schema, forQueryPlanning, supergraph));
    }
    return federateSubgraphs(graphs);
}
exports.buildFederatedQueryGraph = buildFederatedQueryGraph;
function federatedProperties(subgraphs) {
    let vertices = 0;
    const rootKinds = new Set();
    const schemas = [];
    for (const subgraph of subgraphs) {
        vertices += subgraph.verticesCount();
        subgraph.rootKinds().forEach(k => rootKinds.add(k));
        (0, federation_internals_1.assert)(subgraph.sources.size === 1, () => `Subgraphs should only have one sources, got ${subgraph.sources.size} ([${(0, federation_internals_1.mapKeys)(subgraph.sources).join(', ')}])`);
        schemas.push((0, federation_internals_1.firstOf)(subgraph.sources.values()));
    }
    return [vertices + rootKinds.size, rootKinds, schemas];
}
function federateSubgraphs(subgraphs) {
    const [verticesCount, rootKinds, schemas] = federatedProperties(subgraphs);
    const builder = new GraphBuilder(verticesCount);
    rootKinds.forEach(k => builder.createRootVertex(k, new federation_internals_1.ObjectType(federatedGraphRootTypeName(k)), exports.FEDERATED_GRAPH_ROOT_SOURCE, FEDERATED_GRAPH_ROOT_SCHEMA));
    const copyPointers = new Array(subgraphs.length);
    for (const [i, subgraph] of subgraphs.entries()) {
        copyPointers[i] = builder.copyGraph(subgraph);
    }
    for (const [i, subgraph] of subgraphs.entries()) {
        const copyPointer = copyPointers[i];
        for (const rootKind of subgraph.rootKinds()) {
            const rootVertex = copyPointer.copiedVertex(subgraph.root(rootKind));
            builder.addEdge(builder.root(rootKind), rootVertex, transition_1.subgraphEnteringTransition);
            for (const [j, otherSubgraph] of subgraphs.entries()) {
                const otherRootVertex = otherSubgraph.root(rootKind);
                if (otherRootVertex) {
                    const otherCopyPointer = copyPointers[j];
                    builder.addEdge(rootVertex, otherCopyPointer.copiedVertex(otherRootVertex), new transition_1.RootTypeResolution(rootKind));
                }
            }
        }
    }
    for (const [i, subgraph] of subgraphs.entries()) {
        const subgraphSchema = schemas[i];
        const subgraphMetadata = (0, federation_internals_1.federationMetadata)(subgraphSchema);
        (0, federation_internals_1.assert)(subgraphMetadata, `Subgraph ${i} is not a valid federation subgraph`);
        const keyDirective = subgraphMetadata.keyDirective();
        const requireDirective = subgraphMetadata.requiresDirective();
        simpleTraversal(subgraph, v => {
            var _a;
            const type = v.type;
            for (const keyApplication of type.appliedDirectivesOf(keyDirective)) {
                if (!((_a = keyApplication.arguments().resolvable) !== null && _a !== void 0 ? _a : true)) {
                    continue;
                }
                (0, federation_internals_1.assert)((0, federation_internals_1.isInterfaceType)(type) || (0, federation_internals_1.isObjectType)(type), () => `Invalid "@key" application on non Object || Interface type "${type}"`);
                const conditions = (0, federation_internals_1.parseFieldSetArgument)({ parentType: type, directive: keyApplication });
                for (const [j, otherSubgraph] of subgraphs.entries()) {
                    const otherVertices = otherSubgraph.verticesForType(type.name);
                    if (otherVertices.length == 0) {
                        continue;
                    }
                    (0, federation_internals_1.assert)(otherVertices.length == 1, () => `Subgraph ${j} should have a single vertex for type ${type.name} but got ${otherVertices.length}: ${(0, util_1.inspect)(otherVertices)}`);
                    const head = copyPointers[j].copiedVertex(otherVertices[0]);
                    const tail = copyPointers[i].copiedVertex(v);
                    builder.addEdge(head, tail, new transition_1.KeyResolution(), conditions);
                }
            }
        }, e => {
            if (e.transition.kind === 'FieldCollection') {
                const type = e.head.type;
                const field = e.transition.definition;
                (0, federation_internals_1.assert)((0, federation_internals_1.isCompositeType)(type), () => `Non composite type "${type}" should not have field collection edge ${e}`);
                for (const requiresApplication of field.appliedDirectivesOf(requireDirective)) {
                    const conditions = (0, federation_internals_1.parseFieldSetArgument)({ parentType: type, directive: requiresApplication });
                    const head = copyPointers[i].copiedVertex(e.head);
                    const copiedEdge = builder.edge(head, e.index);
                    copiedEdge.addToConditions(conditions);
                }
            }
            return true;
        });
    }
    for (const [i, subgraph] of subgraphs.entries()) {
        const subgraphSchema = schemas[i];
        const subgraphMetadata = (0, federation_internals_1.federationMetadata)(subgraphSchema);
        (0, federation_internals_1.assert)(subgraphMetadata, `Subgraph ${i} is not a valid federation subgraph`);
        const providesDirective = subgraphMetadata.providesDirective();
        simpleTraversal(subgraph, _ => undefined, e => {
            if (e.transition.kind === 'FieldCollection') {
                const type = e.head.type;
                const field = e.transition.definition;
                (0, federation_internals_1.assert)((0, federation_internals_1.isCompositeType)(type), () => `Non composite type "${type}" should not have field collection edge ${e}`);
                for (const providesApplication of field.appliedDirectivesOf(providesDirective)) {
                    const fieldType = (0, federation_internals_1.baseType)(field.type);
                    (0, federation_internals_1.assert)((0, federation_internals_1.isCompositeType)(fieldType), () => `Invalid @provide on field "${field}" whose type "${fieldType}" is not a composite type`);
                    const provided = (0, federation_internals_1.parseFieldSetArgument)({ parentType: fieldType, directive: providesApplication });
                    const head = copyPointers[i].copiedVertex(e.head);
                    const tail = copyPointers[i].copiedVertex(e.tail);
                    const copiedEdge = builder.edge(head, e.index);
                    const copiedTail = builder.makeCopy(tail);
                    builder.updateEdgeTail(copiedEdge, copiedTail);
                    addProvidesEdges(subgraphSchema, builder, copiedTail, provided);
                }
            }
            return true;
        });
    }
    return builder.build(exports.FEDERATED_GRAPH_ROOT_SOURCE);
}
function addProvidesEdges(schema, builder, from, provided) {
    const stack = [[from, provided]];
    const source = from.source;
    while (stack.length > 0) {
        const [v, selectionSet] = stack.pop();
        for (const selection of selectionSet.selections(true)) {
            const element = selection.element();
            if (element.kind == 'Field') {
                const fieldDef = element.definition;
                const existingEdge = builder.edges(v).find(e => e.transition.kind === 'FieldCollection' && e.transition.definition.name === fieldDef.name);
                if (existingEdge) {
                    if (selection.selectionSet) {
                        const copiedTail = builder.makeCopy(existingEdge.tail);
                        builder.updateEdgeTail(existingEdge, copiedTail);
                        stack.push([copiedTail, selection.selectionSet]);
                    }
                }
                else {
                    const fieldType = (0, federation_internals_1.baseType)(fieldDef.type);
                    const existingTail = builder.verticesForType(fieldType.name).find(v => v.source === source);
                    const newTail = existingTail ? existingTail : builder.createNewVertex(fieldType, v.source, schema);
                    if (selection.selectionSet) {
                        const copiedTail = existingTail ? builder.makeCopy(existingTail) : newTail;
                        builder.addEdge(v, copiedTail, new transition_1.FieldCollection(fieldDef, true));
                        stack.push([copiedTail, selection.selectionSet]);
                    }
                    else {
                        builder.addEdge(v, newTail, new transition_1.FieldCollection(fieldDef, true));
                    }
                }
            }
            else {
                const typeCondition = element.typeCondition;
                if (typeCondition) {
                    const existingEdge = builder.edges(v).find(e => e.transition.kind === 'DownCast' && e.transition.castedType.name === typeCondition.name);
                    (0, federation_internals_1.assert)(existingEdge, () => `Shouldn't have ${selection} with no corresponding edge on ${v} (edges are: [${builder.edges(v)}])`);
                    const copiedTail = builder.makeCopy(existingEdge.tail);
                    builder.updateEdgeTail(existingEdge, copiedTail);
                    stack.push([copiedTail, selection.selectionSet]);
                }
                else {
                    stack.push([v, selection.selectionSet]);
                }
            }
        }
    }
}
class GraphBuilder {
    constructor(verticesCount) {
        this.nextIndex = 0;
        this.typesToVertices = new federation_internals_1.MultiMap();
        this.rootVertices = new federation_internals_1.MapWithCachedArrays();
        this.sources = new Map();
        this.vertices = verticesCount ? new Array(verticesCount) : [];
        this.adjacencies = verticesCount ? new Array(verticesCount) : [];
    }
    verticesForType(typeName) {
        const indexes = this.typesToVertices.get(typeName);
        return indexes == undefined ? [] : indexes.map(i => this.vertices[i]);
    }
    root(kind) {
        return this.rootVertices.get(kind);
    }
    addEdge(head, tail, transition, conditions) {
        const edges = this.adjacencies[head.index];
        const edge = new Edge(edges.length, head, tail, transition, conditions);
        edges.push(edge);
    }
    createNewVertex(type, source, schema, index) {
        if (!index) {
            index = this.nextIndex++;
        }
        const vertex = new Vertex(index, type, source);
        const previous = this.vertices[index];
        (0, federation_internals_1.assert)(!previous, () => `Overriding existing vertex ${previous} with ${vertex}`);
        this.vertices[index] = vertex;
        this.typesToVertices.add(type.name, index);
        this.adjacencies[index] = [];
        if (!this.sources.has(source)) {
            this.sources.set(source, schema);
        }
        return vertex;
    }
    createRootVertex(kind, type, source, schema) {
        const vertex = this.createNewVertex(type, source, schema);
        (0, federation_internals_1.assert)(!this.rootVertices.has(kind), () => `Root vertex for ${kind} (${this.rootVertices.get(kind)}) already exists: cannot replace by ${vertex}`);
        this.setAsRoot(kind, vertex.index);
    }
    setAsRoot(kind, index) {
        const vertex = this.vertices[index];
        (0, federation_internals_1.assert)(vertex, () => `Cannot set non-existing vertex at index ${index} as root ${kind}`);
        const rootVertex = toRootVertex(vertex, kind);
        this.vertices[vertex.index] = rootVertex;
        this.rootVertices.set(kind, rootVertex);
        const rootEdges = this.adjacencies[vertex.index];
        for (let i = 0; i < rootEdges.length; i++) {
            rootEdges[i] = rootEdges[i].withNewHead(rootVertex);
        }
    }
    copyGraph(graph) {
        const offset = this.nextIndex;
        for (const vertex of graph.vertices) {
            const newHead = this.getOrCopyVertex(vertex, offset, graph);
            for (const edge of graph.outEdges(vertex, true)) {
                const newTail = this.getOrCopyVertex(edge.tail, offset, graph);
                this.addEdge(newHead, newTail, edge.transition, edge.conditions);
            }
        }
        this.nextIndex += graph.verticesCount();
        const that = this;
        return {
            copiedVertex(original) {
                const vertex = that.vertices[original.index + offset];
                (0, federation_internals_1.assert)(vertex, () => `Vertex ${original} has no copy for offset ${offset}`);
                return vertex;
            }
        };
    }
    vertex(index) {
        return this.vertices[index];
    }
    edge(head, index) {
        return this.adjacencies[head.index][index];
    }
    edges(head) {
        return this.adjacencies[head.index];
    }
    makeCopy(vertex) {
        const newVertex = this.createNewVertex(vertex.type, vertex.source, this.sources.get(vertex.source));
        for (const edge of this.adjacencies[vertex.index]) {
            this.addEdge(newVertex, edge.tail, edge.transition, edge.conditions);
        }
        return newVertex;
    }
    updateEdgeTail(edge, newTail) {
        const newEdge = new Edge(edge.index, edge.head, newTail, edge.transition, edge.conditions);
        this.adjacencies[edge.head.index][edge.index] = newEdge;
        return newEdge;
    }
    getOrCopyVertex(toCopy, indexOffset, graph) {
        const index = toCopy.index + indexOffset;
        let v = this.vertices[index];
        if (!v) {
            v = this.createNewVertex(toCopy.type, toCopy.source, graph.sources.get(toCopy.source), index);
        }
        return v;
    }
    build(name) {
        return new QueryGraph(name, this.vertices, this.adjacencies, this.typesToVertices, this.rootVertices, this.sources);
    }
}
class GraphBuilderFromSchema extends GraphBuilder {
    constructor(name, schema, supergraph) {
        super();
        this.name = name;
        this.schema = schema;
        this.supergraph = supergraph;
        this.isFederatedSubgraph = (0, federation_internals_1.isFederationSubgraphSchema)(schema);
        (0, federation_internals_1.assert)(!this.isFederatedSubgraph || supergraph, `Missing supergraph schema for building the federated subgraph graph`);
    }
    hasDirective(field, directiveFct) {
        const metadata = (0, federation_internals_1.federationMetadata)(this.schema);
        return !!metadata && field.hasAppliedDirective(directiveFct(metadata));
    }
    isExternal(field) {
        const metadata = (0, federation_internals_1.federationMetadata)(this.schema);
        return !!metadata && metadata.isFieldExternal(field);
    }
    addRecursivelyFromRoot(kind, root) {
        this.setAsRoot(kind, this.addTypeRecursively(root).index);
    }
    addTypeRecursively(type) {
        const namedType = (0, federation_internals_1.baseType)(type);
        const existing = this.verticesForType(namedType.name);
        if (existing.length > 0) {
            (0, federation_internals_1.assert)(existing.length == 1, () => `Only one vertex should have been created for type ${namedType.name}, got ${existing.length}: ${(0, util_1.inspect)(this)}`);
            return existing[0];
        }
        const vertex = this.createNewVertex(namedType, this.name, this.schema);
        if ((0, federation_internals_1.isObjectType)(namedType)) {
            this.addObjectTypeEdges(namedType, vertex);
        }
        else if ((0, federation_internals_1.isInterfaceType)(namedType)) {
            if (this.isFederatedSubgraph) {
                this.maybeAddInterfaceFieldsEdges(namedType, vertex);
            }
            this.addAbstractTypeEdges(namedType, vertex);
        }
        else if ((0, federation_internals_1.isUnionType)(namedType)) {
            this.addEdgeForField(namedType.typenameField(), vertex);
            this.addAbstractTypeEdges(namedType, vertex);
        }
        return vertex;
    }
    addObjectTypeEdges(type, head) {
        for (const field of type.allFields()) {
            if (field.isSchemaIntrospectionField()) {
                continue;
            }
            if (this.isExternal(field)) {
                this.addTypeRecursively(field.type);
            }
            else {
                this.addEdgeForField(field, head);
            }
        }
    }
    addEdgeForField(field, head) {
        const tail = this.addTypeRecursively(field.type);
        this.addEdge(head, tail, new transition_1.FieldCollection(field));
    }
    isDirectlyProvidedByType(type, fieldName) {
        const field = type.field(fieldName);
        return field && !this.isExternal(field) && !this.hasDirective(field, (m) => m.requiresDirective());
    }
    maybeAddInterfaceFieldsEdges(type, head) {
        (0, federation_internals_1.assert)(this.supergraph, 'Missing supergraph schema when building a subgraph');
        const supergraphType = this.supergraph.apiSchema.type(type.name);
        if (!supergraphType) {
            return;
        }
        const supergraphRuntimeTypes = supergraphType.possibleRuntimeTypes().map(t => t.name);
        const localRuntimeTypes = supergraphRuntimeTypes.map(t => this.schema.type(t)).filter(t => t !== undefined);
        for (const field of type.allFields()) {
            if (this.isExternal(field) || localRuntimeTypes.some(t => !this.isDirectlyProvidedByType(t, field.name))) {
                continue;
            }
            this.addEdgeForField(field, head);
        }
    }
    addAbstractTypeEdges(type, head) {
        const implementations = (0, federation_internals_1.isInterfaceType)(type) ? type.possibleRuntimeTypes() : type.types();
        for (const implementationType of implementations) {
            const tail = this.addTypeRecursively(implementationType);
            this.addEdge(head, tail, new transition_1.DownCast(type, implementationType));
        }
    }
    addAdditionalAbstractTypeEdges() {
        if (!this.supergraph) {
            return;
        }
        const abstractTypesWithTheirRuntimeTypes = [];
        for (const type of this.schema.types()) {
            if ((0, federation_internals_1.isAbstractType)(type)) {
                const typeInSupergraph = this.supergraph.apiSchema.type(type.name);
                if (!typeInSupergraph) {
                    continue;
                }
                (0, federation_internals_1.assert)((0, federation_internals_1.isAbstractType)(typeInSupergraph), () => `${type} should not be a ${type.kind} in a subgraph but a ${typeInSupergraph.kind} in the supergraph`);
                abstractTypesWithTheirRuntimeTypes.push({
                    type,
                    runtimeTypesInSubgraph: (0, federation_internals_1.possibleRuntimeTypes)(type),
                    runtimeTypesInSupergraph: (0, federation_internals_1.possibleRuntimeTypes)(typeInSupergraph),
                });
            }
        }
        for (let i = 0; i < abstractTypesWithTheirRuntimeTypes.length - 1; i++) {
            const t1 = abstractTypesWithTheirRuntimeTypes[i];
            const t1Vertex = this.addTypeRecursively(t1.type);
            for (let j = i; j < abstractTypesWithTheirRuntimeTypes.length; j++) {
                const t2 = abstractTypesWithTheirRuntimeTypes[j];
                if ((0, federation_internals_1.isInterfaceType)(t1.type) && (0, federation_internals_1.isInterfaceType)(t2.type) && (t1.type.implementsInterface(t2.type) || t2.type.implementsInterface(t1.type))) {
                    continue;
                }
                let addT1ToT2 = false;
                let addT2ToT1 = false;
                if (t1.type === t2.type) {
                    addT1ToT2 = true;
                }
                else {
                    const intersectingLocal = t1.runtimeTypesInSubgraph.filter(o1 => t2.runtimeTypesInSubgraph.includes(o1));
                    if (intersectingLocal.length >= 2) {
                        const isInLocalOtherTypeButNotLocalIntersection = (type, otherType) => (otherType.runtimeTypesInSubgraph.some((t) => t.name === type.name)
                            && !intersectingLocal.some((t) => t.name === type.name));
                        if (!((0, federation_internals_1.isUnionType)(t2.type) || t2.runtimeTypesInSupergraph.some((rt) => isInLocalOtherTypeButNotLocalIntersection(rt, t1)))) {
                            addT1ToT2 = true;
                        }
                        if (!((0, federation_internals_1.isUnionType)(t1.type) || t1.runtimeTypesInSupergraph.some((rt) => isInLocalOtherTypeButNotLocalIntersection(rt, t2)))) {
                            addT2ToT1 = true;
                        }
                    }
                }
                if (addT1ToT2 || addT2ToT1) {
                    const t2Vertex = this.addTypeRecursively(t2.type);
                    if (addT1ToT2) {
                        this.addEdge(t1Vertex, t2Vertex, new transition_1.DownCast(t1.type, t2.type));
                    }
                    if (addT2ToT1) {
                        this.addEdge(t2Vertex, t1Vertex, new transition_1.DownCast(t2.type, t1.type));
                    }
                }
            }
        }
    }
    build() {
        return super.build(this.name);
    }
}
function simpleTraversal(graph, onVertex, onEdges) {
    const marked = new Array(graph.verticesCount());
    const stack = [];
    const maybeAdd = function (vertex) {
        if (!marked[vertex.index]) {
            stack.push(vertex);
            marked[vertex.index] = true;
        }
    };
    graph.roots().forEach(maybeAdd);
    while (stack.length > 0) {
        const vertex = stack.pop();
        onVertex(vertex);
        for (const edge of graph.outEdges(vertex)) {
            const shouldTraverse = onEdges(edge);
            if (shouldTraverse) {
                maybeAdd(edge.tail);
            }
        }
    }
}
exports.simpleTraversal = simpleTraversal;
//# sourceMappingURL=querygraph.js.map