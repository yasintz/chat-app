"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeQueryPlan = exports.MAX_COMPUTED_PLANS = void 0;
const federation_internals_1 = require("@apollo/federation-internals");
const query_graphs_1 = require("@apollo/query-graphs");
const graphql_1 = require("graphql");
const QueryPlan_1 = require("./QueryPlan");
const debug = (0, federation_internals_1.newDebugLogger)('plan');
const SIBLING_TYPENAME_KEY = 'sibling_typename';
exports.MAX_COMPUTED_PLANS = 10000;
const fetchCost = 1000;
const pipeliningCost = 100;
const defaultCostFunction = {
    onFetchGroup: (group) => (fetchCost + selectionCost(group.selection)),
    reduceParallel: (values) => parallelCost(values),
    reduceSequence: (values) => sequenceCost(values),
    reduceDeferred(_, value) {
        return value;
    },
    reduceDefer(nonDeferred, _, deferredValues) {
        return sequenceCost([nonDeferred, parallelCost(deferredValues)]);
    },
};
function parallelCost(values) {
    return sum(values);
}
function sequenceCost(stages) {
    return stages.reduceRight((acc, stage, idx) => (acc + (Math.max(1, idx * pipeliningCost) * stage)), 0);
}
class QueryPlanningTaversal {
    constructor(supergraphSchema, subgraphs, selectionSet, startFetchIdGen, hasDefers, variableDefinitions, statistics, startVertex, rootKind, costFunction, initialContext, excludedEdges = [], excludedConditions = []) {
        this.supergraphSchema = supergraphSchema;
        this.subgraphs = subgraphs;
        this.startFetchIdGen = startFetchIdGen;
        this.hasDefers = hasDefers;
        this.variableDefinitions = variableDefinitions;
        this.statistics = statistics;
        this.startVertex = startVertex;
        this.rootKind = rootKind;
        this.costFunction = costFunction;
        this.closedBranches = [];
        this.isTopLevel = (0, query_graphs_1.isRootVertex)(startVertex);
        this.conditionResolver = (0, query_graphs_1.cachingConditionResolver)(subgraphs, (edge, context, excludedEdges, excludedConditions) => this.resolveConditionPlan(edge, context, excludedEdges, excludedConditions));
        const initialPath = query_graphs_1.GraphPath.create(subgraphs, startVertex);
        const initialOptions = (0, query_graphs_1.createInitialOptions)(initialPath, initialContext, this.conditionResolver, excludedEdges, excludedConditions);
        this.stack = mapOptionsToSelections(selectionSet, initialOptions);
    }
    debugStack() {
        if (this.isTopLevel && debug.enabled) {
            debug.group('Query planning open branches:');
            for (const [selection, options] of this.stack) {
                debug.groupedValues(options, opt => `${(0, query_graphs_1.simultaneousPathsToString)(opt)}`, `${selection}:`);
            }
            debug.groupEnd();
        }
    }
    findBestPlan() {
        while (this.stack.length > 0) {
            this.debugStack();
            const [selection, options] = this.stack.pop();
            this.handleOpenBranch(selection, options);
        }
        this.computeBestPlanFromClosedBranches();
        return this.bestPlan;
    }
    handleOpenBranch(selection, options) {
        const operation = selection.element();
        let newOptions = [];
        for (const option of options) {
            const followupForOption = (0, query_graphs_1.advanceSimultaneousPathsWithOperation)(this.supergraphSchema, option, operation);
            if (!followupForOption) {
                continue;
            }
            if (followupForOption.length === 0) {
                if (operation.kind === 'FragmentElement') {
                    this.closedBranches.push([option.paths.map(p => (0, query_graphs_1.terminateWithNonRequestedTypenameField)(p))]);
                }
                return;
            }
            newOptions = newOptions.concat(followupForOption);
        }
        if (newOptions.length === 0) {
            if (this.isTopLevel) {
                debug.log(`No valid options to advance ${selection} from ${(0, query_graphs_1.advanceOptionsToString)(options)}`);
                throw new Error(`Was not able to find any options for ${selection}: This shouldn't have happened.`);
            }
            else {
                this.stack.splice(0, this.stack.length);
                this.closedBranches.splice(0, this.closedBranches.length);
                return;
            }
        }
        if (selection.selectionSet) {
            for (const branch of mapOptionsToSelections(selection.selectionSet, newOptions)) {
                this.stack.push(branch);
            }
        }
        else {
            const updated = this.maybeEliminateStrictlyMoreCostlyPaths(newOptions);
            this.closedBranches.push(updated);
        }
    }
    maybeEliminateStrictlyMoreCostlyPaths(options) {
        if (options.length === 1) {
            return [options[0].paths];
        }
        const singlePathOptions = options.filter(opt => opt.paths.length === 1);
        if (singlePathOptions.length === 0) {
            return options.map(opt => opt.paths);
        }
        let minJumps = Number.MAX_SAFE_INTEGER;
        let withMinJumps = [];
        for (const option of singlePathOptions) {
            const jumps = option.paths[0].subgraphJumps();
            if (jumps < minJumps) {
                minJumps = jumps;
                withMinJumps = [option.paths];
            }
            else if (jumps === minJumps) {
                withMinJumps.push(option.paths);
            }
        }
        for (const option of singlePathOptions.filter(opt => opt.paths.length > 1)) {
            const jumps = option.paths.reduce((acc, p) => Math.min(acc, p.subgraphJumps()), Number.MAX_SAFE_INTEGER);
            if (jumps <= minJumps) {
                withMinJumps.push(option.paths);
            }
        }
        return withMinJumps;
    }
    newDependencyGraph() {
        const rootType = this.isTopLevel && this.hasDefers ? this.supergraphSchema.schemaDefinition.rootType(this.rootKind) : undefined;
        return FetchDependencyGraph.create(this.subgraphs, this.startFetchIdGen, rootType);
    }
    reorderFirstBranch() {
        const firstBranch = this.closedBranches[0];
        let i = 1;
        while (i < this.closedBranches.length && this.closedBranches[i].length > firstBranch.length) {
            i++;
        }
        this.closedBranches[0] = this.closedBranches[i - 1];
        this.closedBranches[i - 1] = firstBranch;
    }
    pruneClosedBranches() {
        for (let i = 0; i < this.closedBranches.length; i++) {
            const branch = this.closedBranches[i];
            if (branch.length <= 1) {
                continue;
            }
            const pruned = [];
            for (const toCheck of branch) {
                if (!this.optionIsOverriden(toCheck, branch)) {
                    pruned.push(toCheck);
                }
            }
            this.closedBranches[i] = pruned;
        }
    }
    optionIsOverriden(toCheck, allOptions) {
        for (const option of allOptions) {
            if (toCheck === option) {
                continue;
            }
            if (toCheck.every((p) => option.some((o) => p.isOverriddenBy(o)))) {
                return true;
            }
        }
        return false;
    }
    computeBestPlanFromClosedBranches() {
        if (this.closedBranches.length === 0) {
            return;
        }
        this.pruneClosedBranches();
        this.closedBranches.sort((b1, b2) => b1.length > b2.length ? -1 : (b1.length < b2.length ? 1 : 0));
        let planCount = possiblePlans(this.closedBranches);
        debug.log(() => `Query has ${planCount} possible plans`);
        let firstBranch = this.closedBranches[0];
        while (planCount > exports.MAX_COMPUTED_PLANS && firstBranch.length > 1) {
            const prevSize = firstBranch.length;
            firstBranch.pop();
            planCount -= planCount / prevSize;
            this.reorderFirstBranch();
            firstBranch = this.closedBranches[0];
            debug.log(() => `Reduced plans to consider to ${planCount} plans`);
        }
        if (this.statistics) {
            this.statistics.evaluatedPlanCount += planCount;
        }
        debug.log(() => `All branches:${this.closedBranches.map((opts, i) => `\n${i}:${opts.map((opt => `\n - ${(0, query_graphs_1.simultaneousPathsToString)(opt)}`))}`)}`);
        let idxFirstOfLengthOne = 0;
        while (idxFirstOfLengthOne < this.closedBranches.length && this.closedBranches[idxFirstOfLengthOne].length > 1) {
            idxFirstOfLengthOne++;
        }
        let initialTree;
        let initialDependencyGraph;
        if (idxFirstOfLengthOne === this.closedBranches.length) {
            initialTree = query_graphs_1.PathTree.createOp(this.subgraphs, this.startVertex);
            initialDependencyGraph = this.newDependencyGraph();
        }
        else {
            initialTree = query_graphs_1.PathTree.createFromOpPaths(this.subgraphs, this.startVertex, this.closedBranches.slice(idxFirstOfLengthOne).flat(2));
            initialDependencyGraph = this.updatedDependencyGraph(this.newDependencyGraph(), initialTree);
            if (idxFirstOfLengthOne === 0) {
                this.onNewPlan(initialDependencyGraph, initialTree);
                return;
            }
        }
        const otherTrees = this.closedBranches.slice(0, idxFirstOfLengthOne).map(b => b.map(opt => query_graphs_1.PathTree.createFromOpPaths(this.subgraphs, this.startVertex, opt)));
        this.generateAllPlans(initialDependencyGraph, initialTree, otherTrees);
    }
    generateAllPlans(initialDependencyGraph, initialTree, others) {
        const eltIndexes = new Array(others.length);
        let totalCombinations = 1;
        for (let i = 0; i < others.length; ++i) {
            const eltSize = others[i].length;
            (0, federation_internals_1.assert)(eltSize > 0, "Got empty option: this shouldn't have happened");
            eltIndexes[i] = 0;
            totalCombinations *= eltSize;
        }
        for (let i = 0; i < totalCombinations; ++i) {
            const dependencyGraph = initialDependencyGraph.clone();
            let tree = initialTree;
            for (let j = 0; j < others.length; ++j) {
                const t = others[j][eltIndexes[j]];
                this.updatedDependencyGraph(dependencyGraph, t);
                tree = tree.merge(t);
            }
            this.onNewPlan(dependencyGraph, tree);
            for (let idx = 0; idx < others.length; ++idx) {
                if (eltIndexes[idx] == others[idx].length - 1) {
                    eltIndexes[idx] = 0;
                }
                else {
                    eltIndexes[idx] += 1;
                    break;
                }
            }
        }
    }
    cost(dependencyGraph) {
        const { main, deferred } = dependencyGraph.process(this.costFunction, this.rootKind);
        return deferred.length === 0
            ? main
            : this.costFunction.reduceDefer(main, dependencyGraph.deferTracking.primarySelection, deferred);
    }
    updatedDependencyGraph(dependencyGraph, tree) {
        return (0, query_graphs_1.isRootPathTree)(tree)
            ? computeRootFetchGroups(dependencyGraph, tree, this.rootKind)
            : computeNonRootFetchGroups(dependencyGraph, tree, this.rootKind);
    }
    resolveConditionPlan(edge, context, excludedEdges, excludedConditions) {
        const bestPlan = new QueryPlanningTaversal(this.supergraphSchema, this.subgraphs, edge.conditions, 0, false, this.variableDefinitions, undefined, edge.head, 'query', this.costFunction, context, excludedEdges, (0, query_graphs_1.addConditionExclusion)(excludedConditions, edge.conditions)).findBestPlan();
        return bestPlan ? { satisfied: true, cost: bestPlan[2], pathTree: bestPlan[1] } : query_graphs_1.unsatisfiedConditionsResolution;
    }
    onNewPlan(dependencyGraph, tree) {
        const cost = this.cost(dependencyGraph);
        if (!this.bestPlan || cost < this.bestPlan[2]) {
            debug.log(() => this.bestPlan ? `Found better with cost ${cost} (previous had cost ${this.bestPlan[2]}): ${tree}` : `Computed plan with cost ${cost}: ${tree}`);
            this.bestPlan = [dependencyGraph, tree, cost];
        }
        else {
            debug.log(() => `Ignoring plan with cost ${cost} (a better plan with cost ${this.bestPlan[2]} exists): ${tree}`);
        }
    }
}
class LazySelectionSet {
    constructor(_computed, _toCloneOnWrite) {
        this._computed = _computed;
        this._toCloneOnWrite = _toCloneOnWrite;
        (0, federation_internals_1.assert)(_computed || _toCloneOnWrite, 'Should have one of the argument');
    }
    forRead() {
        return this._computed ? this._computed : this._toCloneOnWrite;
    }
    forWrite() {
        if (!this._computed) {
            this._computed = this._toCloneOnWrite.clone();
        }
        return this._computed;
    }
    clone() {
        if (this._computed) {
            return new LazySelectionSet(undefined, this._computed);
        }
        else {
            return this;
        }
    }
    toString() {
        return this.forRead().toString();
    }
}
class FetchGroup {
    constructor(dependencyGraph, index, subgraphName, rootKind, parentType, isEntityFetch, _selection, _inputs, mergeAt, deferRef) {
        this.dependencyGraph = dependencyGraph;
        this.index = index;
        this.subgraphName = subgraphName;
        this.rootKind = rootKind;
        this.parentType = parentType;
        this.isEntityFetch = isEntityFetch;
        this._selection = _selection;
        this._inputs = _inputs;
        this.mergeAt = mergeAt;
        this.deferRef = deferRef;
        this._parents = [];
        this._children = [];
    }
    static create(dependencyGraph, index, subgraphName, rootKind, parentType, isEntityFetch, mergeAt, deferRef) {
        return new FetchGroup(dependencyGraph, index, subgraphName, rootKind, parentType, isEntityFetch, new LazySelectionSet(new federation_internals_1.SelectionSet(parentType)), isEntityFetch ? new LazySelectionSet(new federation_internals_1.SelectionSet(parentType)) : undefined, mergeAt, deferRef);
    }
    cloneShallow(newDependencyGraph) {
        var _a;
        return new FetchGroup(newDependencyGraph, this.index, this.subgraphName, this.rootKind, this.parentType, this.isEntityFetch, this._selection.clone(), (_a = this._inputs) === null || _a === void 0 ? void 0 : _a.clone(), this.mergeAt, this.deferRef);
    }
    set id(id) {
        (0, federation_internals_1.assert)(!this._id, () => `The id for fetch group ${this} is already set`);
        this._id = id;
    }
    get id() {
        return this._id;
    }
    get isTopLevel() {
        return !this.mergeAt;
    }
    get selection() {
        return this._selection.forRead();
    }
    get inputs() {
        var _a;
        return (_a = this._inputs) === null || _a === void 0 ? void 0 : _a.forRead();
    }
    clonedInputs() {
        var _a;
        return (_a = this._inputs) === null || _a === void 0 ? void 0 : _a.clone();
    }
    addParents(parents) {
        for (const parent of parents) {
            this.addParent(parent);
        }
    }
    addParent(parent) {
        if (this.isChildOf(parent.group)) {
            return;
        }
        (0, federation_internals_1.assert)(!parent.group.isParentOf(this), () => `Group ${parent.group} is a parent of ${this}, but the child relationship is broken`);
        (0, federation_internals_1.assert)(!parent.group.isChildOf(this), () => `Group ${parent.group} is a child of ${this}: adding is as parent would create a cycle`);
        this.dependencyGraph.onModification();
        this._parents.push(parent);
        parent.group._children.push(this);
    }
    removeChild(child) {
        if (!this.isParentOf(child)) {
            return;
        }
        this.dependencyGraph.onModification();
        findAndRemoveInPlace((g) => g === child, this._children);
        findAndRemoveInPlace((p) => p.group === this, child._parents);
    }
    isParentOf(maybeChild) {
        return this._children.includes(maybeChild);
    }
    isChildOf(maybeParent) {
        return !!this.parentRelation(maybeParent);
    }
    isChildOfWithArtificialDependency(maybeParent) {
        var _a;
        const relation = this.parentRelation(maybeParent);
        if (!relation || ((_a = relation.path) === null || _a === void 0 ? void 0 : _a.length) !== 0) {
            return false;
        }
        if (!this.inputs) {
            return true;
        }
        return !!maybeParent.inputs && maybeParent.inputs.contains(this.inputs);
    }
    parentRelation(maybeParent) {
        return this._parents.find(({ group }) => maybeParent === group);
    }
    parents() {
        return this._parents;
    }
    parentGroups() {
        return this.parents().map((p) => p.group);
    }
    children() {
        return this._children;
    }
    addInputs(selection) {
        (0, federation_internals_1.assert)(this._inputs, "Shouldn't try to add inputs to a root fetch group");
        if (selection instanceof federation_internals_1.SelectionSet) {
            this._inputs.forWrite().mergeIn(selection);
        }
        else {
            this._inputs.forWrite().add(selection);
        }
    }
    addSelection(path, onPathEnd) {
        this._selection.forWrite().addPath(path, onPathEnd);
    }
    addSelections(selection) {
        this._selection.forWrite().mergeIn(selection);
    }
    canMergeChildIn(child) {
        var _a;
        return this.deferRef === child.deferRef && !!((_a = child.parentRelation(this)) === null || _a === void 0 ? void 0 : _a.path);
    }
    mergeChildIn(child) {
        const relationToChild = child.parentRelation(this);
        (0, federation_internals_1.assert)(relationToChild, () => `Cannot merge ${child} into ${this}: the former is not a child of the latter`);
        const childPathInThis = relationToChild.path;
        (0, federation_internals_1.assert)(childPathInThis, () => `Cannot merge ${child} into ${this}: the path of the former into the later is unknown`);
        this.mergeInInternal(child, childPathInThis);
    }
    canMergeSiblingIn(sibling) {
        const ownParents = this.parents();
        const siblingParents = sibling.parents();
        return this.deferRef === sibling.deferRef
            && this.subgraphName === sibling.subgraphName
            && sameMergeAt(this.mergeAt, sibling.mergeAt)
            && ownParents.length === 1
            && siblingParents.length === 1
            && ownParents[0].group === siblingParents[0].group;
    }
    mergeSiblingIn(sibling) {
        if (sibling.inputs) {
            this.addInputs(sibling.inputs);
        }
        this.mergeInInternal(sibling, []);
    }
    canMergeGrandChildIn(grandChild) {
        var _a;
        const gcParents = grandChild.parents();
        if (gcParents.length !== 1) {
            return false;
        }
        return this.deferRef === grandChild.deferRef && !!gcParents[0].path && !!((_a = gcParents[0].group.parentRelation(this)) === null || _a === void 0 ? void 0 : _a.path);
    }
    mergeGrandChildIn(grandChild) {
        const gcParents = grandChild.parents();
        (0, federation_internals_1.assert)(gcParents.length === 1, () => `Cannot merge ${grandChild} as it has multiple parents ([${gcParents}])`);
        const gcParent = gcParents[0];
        const gcGrandParent = gcParent.group.parentRelation(this);
        (0, federation_internals_1.assert)(gcGrandParent, () => `Cannot merge ${grandChild} into ${this}: the former parent (${gcParent.group}) is not a child of the latter`);
        (0, federation_internals_1.assert)(gcParent.path && gcGrandParent.path, () => `Cannot merge ${grandChild} into ${this}: some paths in parents are unknown`);
        this.mergeInInternal(grandChild, (0, federation_internals_1.concatOperationPaths)(gcGrandParent.path, gcParent.path));
    }
    mergeInWithAllDependencies(other) {
        (0, federation_internals_1.assert)(this.deferRef === other.deferRef, () => `Can only merge unrelated groups within the same @defer block: cannot merge ${this} and ${other}`);
        (0, federation_internals_1.assert)(this.subgraphName === other.subgraphName, () => `Can only merge unrelated groups to the same subraphs: cannot merge ${this} and ${other}`);
        (0, federation_internals_1.assert)(sameMergeAt(this.mergeAt, other.mergeAt), () => `Can only merge unrelated groups at the same "mergeAt": ${this} has mergeAt=${this.mergeAt}, but ${other} has mergeAt=${other.mergeAt}`);
        if (other.inputs) {
            this.addInputs(other.inputs);
        }
        this.mergeInInternal(other, [], true);
    }
    mergeInInternal(merged, path, mergeParentDependencies = false) {
        (0, federation_internals_1.assert)(!merged.isTopLevel, "Shouldn't remove top level groups");
        const mergePathConditionalDirectives = (0, federation_internals_1.conditionalDirectivesInOperationPath)(path);
        let selectionSet;
        if (path.length === 0) {
            selectionSet = merged.selection;
        }
        else {
            selectionSet = new federation_internals_1.SelectionSet(this.selection.parentType);
            selectionSet.addPath(path, (endOfPathSet) => {
                (0, federation_internals_1.assert)(endOfPathSet, () => `Merge path ${path} ends on a non-selectable type`);
                for (const selection of merged.selection.selections()) {
                    const withoutUneededFragments = removeRedundantFragments(selection, endOfPathSet.parentType, mergePathConditionalDirectives);
                    addSelectionOrSelectionSet(endOfPathSet, withoutUneededFragments);
                }
            });
        }
        this._selection.forWrite().mergeIn(selectionSet);
        this.dependencyGraph.onModification();
        this.relocateChildrenOnMergedIn(merged, path);
        if (mergeParentDependencies) {
            this.relocateParentsOnMergedIn(merged);
        }
        this.dependencyGraph.remove(merged);
    }
    removeUselessChild(child) {
        const relationToChild = child.parentRelation(this);
        (0, federation_internals_1.assert)(relationToChild, () => `Cannot remove useless ${child} of ${this}: the former is not a child of the latter`);
        const childPathInThis = relationToChild.path;
        (0, federation_internals_1.assert)(childPathInThis, () => `Cannot remove useless ${child} of ${this}: the path of the former into the later is unknown`);
        this.dependencyGraph.onModification();
        this.relocateChildrenOnMergedIn(child, childPathInThis);
        this.dependencyGraph.remove(child);
    }
    relocateChildrenOnMergedIn(merged, pathInThis) {
        var _a;
        for (const child of merged.children()) {
            if (this.isParentOf(child)) {
                continue;
            }
            const pathInMerged = (_a = child.parentRelation(merged)) === null || _a === void 0 ? void 0 : _a.path;
            child.addParent({ group: this, path: concatPathsInParents(pathInThis, pathInMerged) });
        }
    }
    relocateParentsOnMergedIn(merged) {
        for (const parent of merged.parents()) {
            if (parent.group.isParentOf(this)) {
                continue;
            }
            this.addParent(parent);
        }
    }
    toPlanNode(queryPlannerConfig, variableDefinitions, fragments, operationName) {
        var _a;
        if (this.selection.isEmpty()) {
            return undefined;
        }
        addTypenameFieldForAbstractTypes(this.selection);
        this.selection.validate();
        const inputs = (_a = this._inputs) === null || _a === void 0 ? void 0 : _a.forRead();
        if (inputs) {
            inputs.validate();
        }
        const inputNodes = inputs ? inputs.toSelectionSetNode() : undefined;
        let operation = this.isEntityFetch
            ? operationForEntitiesFetch(this.dependencyGraph.subgraphSchemas.get(this.subgraphName), this.selection, variableDefinitions, operationName)
            : operationForQueryFetch(this.rootKind, this.selection, variableDefinitions, operationName);
        operation = operation.optimize(fragments);
        const operationDocument = (0, federation_internals_1.operationToDocument)(operation);
        const fetchNode = {
            kind: 'Fetch',
            id: this.id,
            serviceName: this.subgraphName,
            requires: inputNodes ? (0, QueryPlan_1.trimSelectionNodes)(inputNodes.selections) : undefined,
            variableUsages: this.selection.usedVariables().map(v => v.name),
            operation: (0, graphql_1.stripIgnoredCharacters)((0, graphql_1.print)(operationDocument)),
            operationKind: schemaRootKindToOperationKind(operation.rootKind),
            operationName: operation.name,
            operationDocumentNode: queryPlannerConfig.exposeDocumentNodeInFetchNode ? operationDocument : undefined,
        };
        return this.isTopLevel
            ? fetchNode
            : {
                kind: 'Flatten',
                path: this.mergeAt,
                node: fetchNode,
            };
    }
    toString() {
        const base = `[${this.index}]${this.deferRef ? '(deferred)' : ''}${this._id ? `{id: ${this._id}}` : ''} ${this.subgraphName}`;
        return this.isTopLevel
            ? `${base}[${this._selection}]`
            : `${base}@(${this.mergeAt})[${this._inputs} => ${this._selection}]`;
    }
}
class DeferredInfo {
    constructor(label, path, parentType, deferred = new Set(), dependencies = new Set()) {
        this.label = label;
        this.path = path;
        this.parentType = parentType;
        this.deferred = deferred;
        this.dependencies = dependencies;
        this.subselection = new federation_internals_1.SelectionSet(parentType);
    }
}
const emptyDeferContext = {
    currentDeferRef: undefined,
    pathToDeferParent: [],
    activeDeferRef: undefined,
    isPartOfQuery: true,
};
function deferContextForConditions(baseContext) {
    return {
        ...baseContext,
        isPartOfQuery: false,
        currentDeferRef: baseContext.activeDeferRef,
    };
}
function deferContextAfterSubgraphJump(baseContext) {
    return baseContext.currentDeferRef === baseContext.activeDeferRef
        ? baseContext
        : {
            ...baseContext,
            activeDeferRef: baseContext.currentDeferRef,
        };
}
class GroupPath {
    constructor(fullPath, pathInGroup, responsePath) {
        this.fullPath = fullPath;
        this.pathInGroup = pathInGroup;
        this.responsePath = responsePath;
    }
    static empty() {
        return new GroupPath([], [], []);
    }
    inGroup() {
        return this.pathInGroup;
    }
    full() {
        return this.fullPath;
    }
    inResponse() {
        return this.responsePath;
    }
    forNewKeyFetch(newGroupContext) {
        return new GroupPath(this.fullPath, newGroupContext, this.responsePath);
    }
    forParentOfGroup(pathOfGroupInParent) {
        return new GroupPath(this.fullPath, (0, federation_internals_1.concatOperationPaths)(pathOfGroupInParent, this.pathInGroup), this.responsePath);
    }
    updatedResponsePath(element) {
        if (element.kind !== 'Field') {
            return this.responsePath;
        }
        let type = element.definition.type;
        const newPath = this.responsePath.concat(element.responseName());
        while (!(0, federation_internals_1.isNamedType)(type)) {
            if ((0, federation_internals_1.isListType)(type)) {
                newPath.push('@');
            }
            type = type.ofType;
        }
        return newPath;
    }
    add(element) {
        return new GroupPath(this.fullPath.concat(element), this.pathInGroup.concat(element), this.updatedResponsePath(element));
    }
    toString() {
        return `[${this.fullPath}]:[${this.pathInGroup}]`;
    }
}
class DeferTracking {
    constructor(rootType) {
        this.topLevelDeferred = new Set();
        this.deferred = new federation_internals_1.MapWithCachedArrays();
        this.primarySelection = rootType ? new federation_internals_1.SelectionSet(rootType) : undefined;
    }
    clone() {
        var _a, _b;
        const cloned = new DeferTracking((_a = this.primarySelection) === null || _a === void 0 ? void 0 : _a.parentType);
        this.topLevelDeferred.forEach((label) => cloned.topLevelDeferred.add(label));
        if (this.primarySelection) {
            (_b = cloned.primarySelection) === null || _b === void 0 ? void 0 : _b.mergeIn(this.primarySelection.clone());
        }
        for (const deferredBlock of this.deferred.values()) {
            const clonedInfo = new DeferredInfo(deferredBlock.label, deferredBlock.path, deferredBlock.parentType, new Set(deferredBlock.deferred));
            clonedInfo.subselection.mergeIn(deferredBlock.subselection.clone());
            cloned.deferred.set(deferredBlock.label, clonedInfo);
        }
        return cloned;
    }
    registerDefer({ deferContext, deferArgs, path, parentType, }) {
        if (!this.primarySelection) {
            return;
        }
        (0, federation_internals_1.assert)(deferArgs.label, 'All @defer should have be labelled at this point');
        let deferredBlock = this.deferred.get(deferArgs.label);
        if (!deferredBlock) {
            deferredBlock = new DeferredInfo(deferArgs.label, path, parentType);
            this.deferred.set(deferArgs.label, deferredBlock);
        }
        const parentRef = deferContext.currentDeferRef;
        if (!parentRef) {
            this.topLevelDeferred.add(deferArgs.label);
            this.primarySelection.addPath(deferContext.pathToDeferParent);
        }
        else {
            const parentInfo = this.deferred.get(parentRef);
            (0, federation_internals_1.assert)(parentInfo, `Cannot find info for parent ${parentRef} or ${deferArgs.label}`);
            parentInfo.deferred.add(deferArgs.label);
            parentInfo.subselection.addPath(deferContext.pathToDeferParent);
        }
    }
    updateSubselection(deferContext) {
        if (!this.primarySelection || !deferContext.isPartOfQuery) {
            return;
        }
        const parentRef = deferContext.currentDeferRef;
        if (parentRef) {
            const info = this.deferred.get(parentRef);
            (0, federation_internals_1.assert)(info, () => `Cannot find info for label ${parentRef}`);
            info.subselection.addPath(deferContext.pathToDeferParent);
        }
        else {
            this.primarySelection.addPath(deferContext.pathToDeferParent);
        }
    }
    getBlock(label) {
        return this.deferred.get(label);
    }
    addDependency(label, idDependency) {
        const info = this.deferred.get(label);
        (0, federation_internals_1.assert)(info, () => `Cannot find info for label ${label}`);
        info.dependencies.add(idDependency);
    }
    defersInParent(parentRef) {
        var _a;
        const labels = parentRef ? (_a = this.deferred.get(parentRef)) === null || _a === void 0 ? void 0 : _a.deferred : this.topLevelDeferred;
        return labels
            ? (0, federation_internals_1.setValues)(labels).map((label) => {
                const info = this.deferred.get(label);
                (0, federation_internals_1.assert)(info, () => `Should not have referenced ${label} without an existing info`);
                return info;
            })
            : [];
    }
}
class FetchDependencyGraph {
    constructor(subgraphSchemas, federatedQueryGraph, startingIdGen, rootGroups, groups, deferTracking) {
        this.subgraphSchemas = subgraphSchemas;
        this.federatedQueryGraph = federatedQueryGraph;
        this.startingIdGen = startingIdGen;
        this.rootGroups = rootGroups;
        this.groups = groups;
        this.deferTracking = deferTracking;
        this.isReduced = false;
        this.isOptimized = false;
        this.fetchIdGen = startingIdGen;
    }
    static create(federatedQueryGraph, startingIdGen, rootTypeForDefer) {
        return new FetchDependencyGraph(federatedQueryGraph.sources, federatedQueryGraph, startingIdGen, new federation_internals_1.MapWithCachedArrays(), [], new DeferTracking(rootTypeForDefer));
    }
    federationMetadata(subgraphName) {
        const schema = this.subgraphSchemas.get(subgraphName);
        (0, federation_internals_1.assert)(schema, () => `Unknown schema ${subgraphName}`);
        const metadata = (0, federation_internals_1.federationMetadata)(schema);
        (0, federation_internals_1.assert)(metadata, () => `Schema ${subgraphName} should be a federation subgraph`);
        return metadata;
    }
    nextFetchId() {
        return this.fetchIdGen;
    }
    clone() {
        const cloned = new FetchDependencyGraph(this.subgraphSchemas, this.federatedQueryGraph, this.startingIdGen, new federation_internals_1.MapWithCachedArrays(), new Array(this.groups.length), this.deferTracking.clone());
        for (const group of this.groups) {
            cloned.groups[group.index] = group.cloneShallow(cloned);
        }
        for (const root of this.rootGroups.values()) {
            cloned.rootGroups.set(root.subgraphName, cloned.groups[root.index]);
        }
        for (const group of this.groups) {
            const clonedGroup = cloned.groups[group.index];
            for (const parent of group.parents()) {
                clonedGroup.addParent({
                    group: cloned.groups[parent.group.index],
                    path: parent.path
                });
            }
        }
        return cloned;
    }
    getOrCreateRootFetchGroup({ subgraphName, rootKind, parentType, }) {
        let group = this.rootGroups.get(subgraphName);
        if (!group) {
            group = this.createRootFetchGroup({ subgraphName, rootKind, parentType });
            this.rootGroups.set(subgraphName, group);
        }
        return group;
    }
    rootSubgraphs() {
        return this.rootGroups.keys();
    }
    isRootGroup(group) {
        return group === this.rootGroups.get(group.subgraphName);
    }
    createRootFetchGroup({ subgraphName, rootKind, parentType, }) {
        const group = this.newFetchGroup({ subgraphName, parentType, isEntityFetch: false, rootKind });
        this.rootGroups.set(subgraphName, group);
        return group;
    }
    newFetchGroup({ subgraphName, parentType, isEntityFetch, rootKind, mergeAt, deferRef, }) {
        this.onModification();
        const newGroup = FetchGroup.create(this, this.groups.length, subgraphName, rootKind, parentType, isEntityFetch, mergeAt, deferRef);
        this.groups.push(newGroup);
        return newGroup;
    }
    getOrCreateKeyFetchGroup({ subgraphName, mergeAt, parent, conditionsGroups, deferRef, }) {
        var _a;
        for (const existing of parent.group.children()) {
            if (existing.subgraphName === subgraphName
                && existing.mergeAt
                && sameMergeAt(existing.mergeAt, mergeAt)
                && !this.isInGroupsOrTheirAncestors(existing, conditionsGroups)
                && existing.deferRef === deferRef) {
                const existingPathInParent = (_a = existing.parentRelation(parent.group)) === null || _a === void 0 ? void 0 : _a.path;
                if (!samePathsInParents(existingPathInParent, parent.path)) {
                    this.removePathInParent(parent.group, existing);
                }
                return existing;
            }
        }
        const newGroup = this.newKeyFetchGroup({ subgraphName, mergeAt, deferRef });
        newGroup.addParent(parent);
        return newGroup;
    }
    removePathInParent(parent, child) {
        parent.removeChild(child);
        child.addParent({ group: parent });
    }
    newRootTypeFetchGroup({ subgraphName, rootKind, parentType, mergeAt, deferRef, }) {
        return this.newFetchGroup({ subgraphName, parentType, isEntityFetch: false, rootKind, mergeAt, deferRef });
    }
    isInGroupsOrTheirAncestors(toCheck, conditions) {
        const stack = conditions.concat();
        while (stack.length > 0) {
            const group = stack.pop();
            if (toCheck === group) {
                return true;
            }
            stack.push(...group.parentGroups());
        }
        return false;
    }
    newKeyFetchGroup({ subgraphName, mergeAt, deferRef, }) {
        const parentType = this.federationMetadata(subgraphName).entityType();
        (0, federation_internals_1.assert)(parentType, () => `Subgraph ${subgraphName} has not entities defined`);
        return this.newFetchGroup({ subgraphName, parentType, isEntityFetch: true, rootKind: 'query', mergeAt, deferRef });
    }
    remove(toRemove) {
        this.onModification();
        const children = toRemove.children().concat();
        const parents = toRemove.parents().concat();
        for (const child of children) {
            (0, federation_internals_1.assert)(child.parents().length > 1, () => `Cannot remove ${toRemove} as it is the *only* parent of ${child}`);
            toRemove.removeChild(child);
        }
        for (const parent of parents) {
            parent.group.removeChild(toRemove);
        }
        this.groups.splice(toRemove.index, 1);
        for (let i = toRemove.index; i < this.groups.length; i++) {
            --this.groups[i].index;
        }
    }
    onModification() {
        this.isReduced = false;
        this.isOptimized = false;
    }
    reduce() {
        if (this.isReduced) {
            return;
        }
        for (const group of this.groups) {
            this.dfsRemoveRedundantEdges(group);
        }
        this.isReduced = true;
    }
    reduceAndOptimize() {
        if (this.isOptimized) {
            return;
        }
        this.reduce();
        for (const group of this.rootGroups.values()) {
            this.removeEmptyGroups(group);
        }
        for (const group of this.rootGroups.values()) {
            this.removeUselessGroups(group);
        }
        for (const group of this.rootGroups.values()) {
            this.mergeChildFetchesForSameSubgraphAndPath(group);
        }
        this.mergeFetchesToSameSubgraphAndSameInputs();
        this.isOptimized = true;
    }
    removeEmptyGroups(group) {
        const children = group.children().concat();
        if (group.selection.isEmpty() && !this.isRootGroup(group)) {
            this.remove(group);
        }
        for (const g of children) {
            this.removeEmptyGroups(g);
        }
    }
    removeUselessGroups(group) {
        for (const child of group.children()) {
            this.removeUselessGroups(child);
        }
        if (group.inputs && group.inputs.contains(group.selection)) {
            if (group.children().length === 0) {
                this.remove(group);
            }
            else {
                const parents = group.parents();
                const parent = parents[0];
                if (parents.length === 1 && parent.path) {
                    parent.group.removeUselessChild(group);
                }
            }
        }
    }
    mergeChildFetchesForSameSubgraphAndPath(group) {
        const children = group.children();
        if (children.length > 1) {
            for (let i = 0; i < children.length; i++) {
                const gi = children[i];
                let j = i + 1;
                while (j < children.length) {
                    const gj = children[j];
                    if (gi.canMergeSiblingIn(gj)) {
                        gi.mergeSiblingIn(gj);
                        this.dfsRemoveRedundantEdges(gi);
                    }
                    else {
                        ++j;
                    }
                }
            }
        }
        for (const g of children) {
            this.mergeChildFetchesForSameSubgraphAndPath(g);
        }
    }
    mergeFetchesToSameSubgraphAndSameInputs() {
        const makeKey = (g) => { var _a, _b; return `${toValidGraphQLName(g.subgraphName)}-${(_b = (_a = g.mergeAt) === null || _a === void 0 ? void 0 : _a.join('::')) !== null && _b !== void 0 ? _b : ''}`; };
        const bySubgraphs = new federation_internals_1.MultiMap();
        for (const group of this.groups) {
            if (group.inputs) {
                bySubgraphs.add(makeKey(group), group);
            }
        }
        for (const groups of bySubgraphs.values()) {
            if (groups.length <= 1) {
                continue;
            }
            const toMergeBuckets = [];
            while (groups.length > 1) {
                const group = groups.pop();
                const bucket = [group];
                let i = 0;
                while (i < groups.length) {
                    const current = groups[i];
                    if (group.deferRef === current.deferRef && group.inputs.equals(current.inputs)) {
                        bucket.push(current);
                        groups.splice(i, 1);
                    }
                    else {
                        ++i;
                    }
                }
                if (bucket.length > 1) {
                    toMergeBuckets.push(bucket);
                }
            }
            for (const bucket of toMergeBuckets) {
                const group = bucket.pop();
                for (const other of bucket) {
                    group.mergeInWithAllDependencies(other);
                }
            }
        }
        this.reduce();
    }
    dfsRemoveRedundantEdges(from) {
        for (const startVertex of from.children()) {
            const stack = startVertex.children().concat();
            while (stack.length > 0) {
                const v = stack.pop();
                from.removeChild(v);
                stack.push(...v.children());
            }
        }
    }
    extractChildrenAndDeferredDependencies(group) {
        const children = [];
        const deferredGroups = new federation_internals_1.SetMultiMap();
        for (const child of group.children()) {
            if (group.deferRef === child.deferRef) {
                children.push(child);
            }
            else {
                (0, federation_internals_1.assert)(child.deferRef, () => `${group} has deferRef "${group.deferRef}", so its child ${child} cannot have a top-level deferRef`);
                if (!group.selection.isEmpty()) {
                    if (!group.id) {
                        group.id = String(this.fetchIdGen++);
                    }
                    this.deferTracking.addDependency(child.deferRef, group.id);
                }
                deferredGroups.add(child.deferRef, child);
            }
        }
        return { children, deferredGroups };
    }
    processGroup(processor, group) {
        const { children, deferredGroups } = this.extractChildrenAndDeferredDependencies(group);
        const processed = processor.onFetchGroup(group);
        if (children.length == 0) {
            return { main: processed, unhandled: [], deferredGroups };
        }
        const groupIsOnlyParentOfAllChildren = children.every(g => g.parents().length === 1);
        if (groupIsOnlyParentOfAllChildren) {
            const { mainSequence, unhandled, deferredGroups: allDeferredGroups, } = this.processRootMainGroups({
                processor,
                rootGroups: children,
                rootsAreParallel: true,
                initialDeferredGroups: deferredGroups,
            });
            return {
                main: processor.reduceSequence([processed].concat(mainSequence)),
                unhandled,
                deferredGroups: allDeferredGroups,
            };
        }
        else {
            return {
                main: processed,
                unhandled: children.map(g => [g, g.parents().filter((p) => p.group !== group)]),
                deferredGroups,
            };
        }
    }
    processGroups(processor, groups, processInParallel, remaining) {
        const processedNodes = [];
        const allDeferredGroups = new federation_internals_1.SetMultiMap();
        let remainingNext = remaining;
        let toHandleNext = [];
        for (const group of groups) {
            const { main, deferredGroups, unhandled } = this.processGroup(processor, group);
            processedNodes.push(main);
            allDeferredGroups.addAll(deferredGroups);
            const [canHandle, newRemaining] = this.mergeRemainings(remainingNext, unhandled);
            toHandleNext = toHandleNext.concat(canHandle);
            remainingNext = newRemaining;
        }
        return {
            processed: processInParallel ? processor.reduceParallel(processedNodes) : processor.reduceSequence(processedNodes),
            next: toHandleNext,
            unhandled: remainingNext,
            deferredGroups: allDeferredGroups,
        };
    }
    mergeRemainings(r1, r2) {
        const unhandled = [];
        const toHandle = [];
        for (const [g, edges] of r1) {
            const newEdges = this.mergeRemaingsAndRemoveIfFound(g, edges, r2);
            if (newEdges.length == 0) {
                toHandle.push(g);
            }
            else {
                unhandled.push([g, newEdges]);
            }
        }
        unhandled.push(...r2);
        return [toHandle, unhandled];
    }
    mergeRemaingsAndRemoveIfFound(group, inEdges, otherGroups) {
        const idx = otherGroups.findIndex(g => g[0] === group);
        if (idx < 0) {
            return inEdges;
        }
        else {
            const otherEdges = otherGroups[idx][1];
            otherGroups.splice(idx, 1);
            return inEdges.filter(e => otherEdges.includes(e));
        }
    }
    processRootMainGroups({ processor, rootGroups, rootsAreParallel, initialDeferredGroups, }) {
        let nextGroups = rootGroups;
        let remainingNext = [];
        const mainSequence = [];
        const allDeferredGroups = initialDeferredGroups
            ? new federation_internals_1.SetMultiMap(initialDeferredGroups)
            : new federation_internals_1.SetMultiMap();
        let processInParallel = rootsAreParallel;
        while (nextGroups.length > 0) {
            const { processed, next, unhandled, deferredGroups } = this.processGroups(processor, nextGroups, processInParallel, remainingNext);
            processInParallel = true;
            mainSequence.push(processed);
            const [canHandle, newRemaining] = this.mergeRemainings(remainingNext, unhandled);
            remainingNext = newRemaining;
            nextGroups = canHandle.concat(next);
            allDeferredGroups.addAll(deferredGroups);
        }
        return {
            mainSequence,
            unhandled: remainingNext,
            deferredGroups: allDeferredGroups,
        };
    }
    processRootGroups({ processor, rootGroups, rootsAreParallel = true, currentDeferRef, otherDeferGroups = undefined, }) {
        var _a;
        const { mainSequence, unhandled, deferredGroups, } = this.processRootMainGroups({ processor, rootsAreParallel, rootGroups });
        (0, federation_internals_1.assert)(unhandled.length == 0, () => `Root groups ${rootGroups} should have no remaining groups unhandled, but got ${unhandled}`);
        const allDeferredGroups = new federation_internals_1.SetMultiMap();
        if (otherDeferGroups) {
            allDeferredGroups.addAll(otherDeferGroups);
        }
        allDeferredGroups.addAll(deferredGroups);
        const defersInCurrent = this.deferTracking.defersInParent(currentDeferRef);
        const handledDefersInCurrent = new Set(defersInCurrent.map((d) => d.label));
        const unhandledDefersInCurrent = (0, federation_internals_1.mapKeys)(allDeferredGroups).filter((label) => !handledDefersInCurrent.has(label));
        let unhandledDeferGroups = undefined;
        if (unhandledDefersInCurrent.length > 0) {
            unhandledDeferGroups = new federation_internals_1.SetMultiMap();
            for (const label of unhandledDefersInCurrent) {
                unhandledDeferGroups.set(label, allDeferredGroups.get(label));
            }
        }
        const allDeferred = [];
        for (const defer of defersInCurrent) {
            const groups = (_a = allDeferredGroups.get(defer.label)) !== null && _a !== void 0 ? _a : [];
            const { mainSequence: mainSequenceOfDefer, deferred: deferredOfDefer } = this.processRootGroups({
                processor,
                rootGroups: Array.from(groups),
                rootsAreParallel: true,
                currentDeferRef: defer.label,
                otherDeferGroups: unhandledDeferGroups,
            });
            const mainReduced = processor.reduceSequence(mainSequenceOfDefer);
            const processed = deferredOfDefer.length === 0
                ? mainReduced
                : processor.reduceDefer(mainReduced, defer.subselection, deferredOfDefer);
            allDeferred.push(processor.reduceDeferred(defer, processed));
        }
        return { mainSequence, deferred: allDeferred };
    }
    process(processor, rootKind) {
        this.reduceAndOptimize();
        const { mainSequence, deferred } = this.processRootGroups({
            processor,
            rootGroups: this.rootGroups.values(),
            rootsAreParallel: rootKind === 'query',
        });
        return {
            main: processor.reduceSequence(mainSequence),
            deferred,
        };
    }
    dumpOnConsole(msg) {
        if (msg) {
            console.log(msg);
        }
        console.log('Groups:');
        for (const group of this.groups) {
            console.log(`  ${group}`);
        }
        console.log('Children relationships:');
        for (const group of this.groups) {
            const children = group.children();
            if (children.length === 1) {
                console.log(`  [${group.index}] => [ ${children[0]} ]`);
            }
            else if (children.length !== 0) {
                console.log(`  [${group.index}] => [\n    ${children.join('\n    ')}\n  ]`);
            }
        }
        console.log('Parent relationships:');
        const printParentRelation = (rel) => (rel.path ? `${rel.group} (path: [${rel.path.join(', ')}])` : rel.group.toString());
        for (const group of this.groups) {
            const parents = group.parents();
            if (parents.length === 1) {
                console.log(`  [${group.index}] => [ ${printParentRelation(parents[0])} ]`);
            }
            else if (parents.length !== 0) {
                console.log(`  [${group.index}] => [\n    ${parents.map(printParentRelation).join('\n    ')}\n  ]`);
            }
        }
        console.log('--------');
    }
    toString() {
        return this.rootGroups.values().map(g => this.toStringInternal(g, "")).join('\n');
    }
    toStringInternal(group, indent) {
        const children = group.children();
        return [indent + group.subgraphName + ' <- ' + children.map((child) => child.subgraphName).join(', ')]
            .concat(children
            .flatMap(g => g.children().length == 0
            ? []
            : this.toStringInternal(g, indent + "  ")))
            .join('\n');
    }
}
function optimizeSiblingTypenames(selectionSet) {
    const selections = selectionSet.selections();
    let updatedSelections = undefined;
    let typenameSelection = undefined;
    let firstFieldSelection = undefined;
    for (let i = 0; i < selections.length; i++) {
        const selection = selections[i];
        let updated;
        if (!typenameSelection && selection.kind === 'FieldSelection' && selection.field.name === federation_internals_1.typenameFieldName) {
            updated = undefined;
            typenameSelection = selection;
        }
        else {
            const updatedSubSelection = selection.selectionSet ? optimizeSiblingTypenames(selection.selectionSet) : undefined;
            if (updatedSubSelection === selection.selectionSet) {
                updated = selection;
            }
            else {
                updated = selection.withUpdatedSubSelection(updatedSubSelection);
            }
            if (!firstFieldSelection && updated.kind === 'FieldSelection') {
                firstFieldSelection = updated;
            }
        }
        if (updated !== selection && !updatedSelections) {
            updatedSelections = [];
            for (let j = 0; j < i; j++) {
                updatedSelections.push(selections[j]);
            }
        }
        if (updatedSelections && !!updated) {
            updatedSelections.push(updated);
        }
    }
    if (!updatedSelections || updatedSelections.length === 0) {
        return selectionSet;
    }
    if (typenameSelection) {
        if (firstFieldSelection) {
            firstFieldSelection.element().addAttachement(SIBLING_TYPENAME_KEY, typenameSelection.field.alias ? typenameSelection.field.alias : '');
        }
        else {
            updatedSelections = [typenameSelection].concat(updatedSelections);
        }
    }
    return new federation_internals_1.SelectionSet(selectionSet.parentType, selectionSet.fragments).addAll(updatedSelections);
}
function withSiblingTypenameOptimizedAway(operation) {
    const updatedSelectionSet = optimizeSiblingTypenames(operation.selectionSet);
    if (updatedSelectionSet === operation.selectionSet) {
        return operation;
    }
    return new federation_internals_1.Operation(operation.rootKind, updatedSelectionSet, operation.variableDefinitions, operation.name);
}
function computeQueryPlan({ config, supergraphSchema, federatedQueryGraph, operation, }) {
    var _a;
    if (operation.rootKind === 'subscription') {
        throw federation_internals_1.ERRORS.UNSUPPORTED_FEATURE.err('Query planning does not currently support subscriptions.', { nodes: [(0, graphql_1.parse)(operation.toString())] });
    }
    const statistics = {
        evaluatedPlanCount: 0,
    };
    const reuseQueryFragments = (_a = config.reuseQueryFragments) !== null && _a !== void 0 ? _a : true;
    let fragments = operation.selectionSet.fragments;
    if (fragments && reuseQueryFragments) {
        fragments = addTypenameFieldForAbstractTypesInNamedFragments(fragments);
    }
    else {
        fragments = undefined;
    }
    operation = operation.expandAllFragments();
    operation = withoutIntrospection(operation);
    operation = withSiblingTypenameOptimizedAway(operation);
    let assignedDeferLabels = undefined;
    let hasDefers = false;
    let deferConditions = undefined;
    if (config.incrementalDelivery.enableDefer) {
        ({ operation, hasDefers, assignedDeferLabels, deferConditions } = operation.withNormalizedDefer());
    }
    else {
        operation = operation.withoutDefer();
    }
    debug.group(() => `Computing plan for\n${operation}`);
    if (operation.selectionSet.isEmpty()) {
        debug.groupEnd('Empty plan');
        return {
            plan: { kind: 'QueryPlan' },
            statistics,
        };
    }
    const root = federatedQueryGraph.root(operation.rootKind);
    (0, federation_internals_1.assert)(root, () => `Shouldn't have a ${operation.rootKind} operation if the subgraphs don't have a ${operation.rootKind} root`);
    const processor = fetchGroupToPlanProcessor({
        config,
        variableDefinitions: operation.variableDefinitions,
        fragments,
        operationName: operation.name,
        assignedDeferLabels,
    });
    let rootNode;
    if (deferConditions && deferConditions.size > 0) {
        (0, federation_internals_1.assert)(hasDefers, 'Should not have defer conditions without @defer');
        rootNode = computePlanForDeferConditionals({
            supergraphSchema,
            federatedQueryGraph,
            operation,
            processor,
            root,
            deferConditions,
            statistics,
        });
    }
    else {
        rootNode = computePlanInternal({
            supergraphSchema,
            federatedQueryGraph,
            operation,
            processor,
            root,
            hasDefers,
            statistics,
        });
    }
    debug.groupEnd('Query plan computed');
    return {
        plan: { kind: 'QueryPlan', node: rootNode },
        statistics,
    };
}
exports.computeQueryPlan = computeQueryPlan;
function computePlanInternal({ supergraphSchema, federatedQueryGraph, operation, processor, root, hasDefers, statistics, }) {
    let main = undefined;
    let primarySelection = undefined;
    let deferred = [];
    if (operation.rootKind === 'mutation') {
        const dependencyGraphs = computeRootSerialDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root, hasDefers, statistics);
        for (const dependencyGraph of dependencyGraphs) {
            const { main: localMain, deferred: localDeferred } = dependencyGraph.process(processor, operation.rootKind);
            main = main ? processor.reduceSequence([main, localMain]) : localMain;
            deferred = deferred.concat(localDeferred);
            const newSelection = dependencyGraph.deferTracking.primarySelection;
            if (newSelection) {
                if (primarySelection) {
                    primarySelection.mergeIn(newSelection);
                }
                else {
                    primarySelection = newSelection.clone();
                }
            }
        }
    }
    else {
        const dependencyGraph = computeRootParallelDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root, 0, hasDefers, statistics);
        ({ main, deferred } = dependencyGraph.process(processor, operation.rootKind));
        primarySelection = dependencyGraph.deferTracking.primarySelection;
    }
    if (deferred.length > 0) {
        (0, federation_internals_1.assert)(primarySelection, 'Should have had a primary selection created');
        return processor.reduceDefer(main, primarySelection, deferred);
    }
    return main;
}
function computePlanForDeferConditionals({ supergraphSchema, federatedQueryGraph, operation, processor, root, deferConditions, statistics, }) {
    return generateConditionNodes(operation, Array.from(deferConditions.entries()), 0, (op) => computePlanInternal({
        supergraphSchema,
        federatedQueryGraph,
        operation: op,
        processor,
        root,
        hasDefers: true,
        statistics,
    }));
}
function generateConditionNodes(operation, conditions, idx, onFinalOperation) {
    if (idx >= conditions.length) {
        return onFinalOperation(operation);
    }
    const [variable, labels] = conditions[idx];
    const ifOperation = operation;
    const elseOperation = operation.withoutDefer(labels);
    return {
        kind: 'Condition',
        condition: variable,
        ifClause: generateConditionNodes(ifOperation, conditions, idx + 1, onFinalOperation),
        elseClause: generateConditionNodes(elseOperation, conditions, idx + 1, onFinalOperation),
    };
}
function isIntrospectionSelection(selection) {
    return selection.kind == 'FieldSelection' && selection.element().definition.isIntrospectionField();
}
function mapOptionsToSelections(selectionSet, options) {
    return selectionSet.selections(true).map(node => [node, options]);
}
function possiblePlans(closedBranches) {
    let totalCombinations = 1;
    for (let i = 0; i < closedBranches.length; ++i) {
        const eltSize = closedBranches[i].length;
        if (eltSize === 0) {
            return 0;
        }
        totalCombinations *= eltSize;
    }
    return totalCombinations;
}
function sum(arr) {
    return arr.reduce((a, b) => a + b, 0);
}
function selectionCost(selection, depth = 1) {
    return selection ? selection.selections().reduce((prev, curr) => prev + depth + selectionCost(curr.selectionSet, depth + 1), 0) : 0;
}
function withoutIntrospection(operation) {
    if (!operation.selectionSet.selections().some(isIntrospectionSelection)) {
        return operation;
    }
    const newSelections = operation.selectionSet.selections().filter(s => !isIntrospectionSelection(s));
    return new federation_internals_1.Operation(operation.rootKind, new federation_internals_1.SelectionSet(operation.selectionSet.parentType).addAll(newSelections), operation.variableDefinitions, operation.name);
}
function computeRootParallelDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root, startFetchIdGen, hasDefer, statistics) {
    return computeRootParallelBestPlan(supergraphSchema, operation.selectionSet, operation.variableDefinitions, federatedQueryGraph, root, startFetchIdGen, hasDefer, statistics)[0];
}
function computeRootParallelBestPlan(supergraphSchema, selection, variables, federatedQueryGraph, root, startFetchIdGen, hasDefers, statistics) {
    const planningTraversal = new QueryPlanningTaversal(supergraphSchema, federatedQueryGraph, selection, startFetchIdGen, hasDefers, variables, statistics, root, root.rootKind, defaultCostFunction, query_graphs_1.emptyContext);
    const plan = planningTraversal.findBestPlan();
    return plan !== null && plan !== void 0 ? plan : createEmptyPlan(federatedQueryGraph, root);
}
function createEmptyPlan(federatedQueryGraph, root) {
    return [
        FetchDependencyGraph.create(federatedQueryGraph, 0, undefined),
        query_graphs_1.PathTree.createOp(federatedQueryGraph, root),
        0
    ];
}
function onlyRootSubgraph(graph) {
    const subgraphs = graph.rootSubgraphs();
    (0, federation_internals_1.assert)(subgraphs.length === 1, () => `${graph} should have only one root, but has [${graph.rootSubgraphs()}]`);
    return subgraphs[0];
}
function computeRootSerialDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root, hasDefers, statistics) {
    const rootType = hasDefers ? supergraphSchema.schemaDefinition.rootType(root.rootKind) : undefined;
    const splittedRoots = splitTopLevelFields(operation.selectionSet);
    const graphs = [];
    let startingFetchId = 0;
    let [prevDepGraph, prevPaths] = computeRootParallelBestPlan(supergraphSchema, splittedRoots[0], operation.variableDefinitions, federatedQueryGraph, root, startingFetchId, hasDefers, statistics);
    let prevSubgraph = onlyRootSubgraph(prevDepGraph);
    for (let i = 1; i < splittedRoots.length; i++) {
        const [newDepGraph, newPaths] = computeRootParallelBestPlan(supergraphSchema, splittedRoots[i], operation.variableDefinitions, federatedQueryGraph, root, prevDepGraph.nextFetchId(), hasDefers, statistics);
        const newSubgraph = onlyRootSubgraph(newDepGraph);
        if (prevSubgraph === newSubgraph) {
            prevPaths = prevPaths.concat(newPaths);
            prevDepGraph = computeRootFetchGroups(FetchDependencyGraph.create(federatedQueryGraph, startingFetchId, rootType), prevPaths, root.rootKind);
        }
        else {
            startingFetchId = prevDepGraph.nextFetchId();
            graphs.push(prevDepGraph);
            [prevDepGraph, prevPaths, prevSubgraph] = [newDepGraph, newPaths, newSubgraph];
        }
    }
    graphs.push(prevDepGraph);
    return graphs;
}
function splitTopLevelFields(selectionSet) {
    return selectionSet.selections().flatMap(selection => {
        if (selection.kind === 'FieldSelection') {
            return [(0, federation_internals_1.selectionSetOf)(selectionSet.parentType, selection)];
        }
        else {
            return splitTopLevelFields(selection.selectionSet).map(s => (0, federation_internals_1.selectionSetOfElement)(selection.element(), s));
        }
    });
}
function toValidGraphQLName(subgraphName) {
    const sanitized = subgraphName
        .replace(/-/ig, '_')
        .replace(/[^_0-9A-Za-z]/ig, '');
    return sanitized.match(/^[0-9].*/i) ? '_' + sanitized : sanitized;
}
function sanitizeAndPrintSubselection(subSelection) {
    var _a;
    return (_a = subSelection.withoutEmptyBranches()) === null || _a === void 0 ? void 0 : _a.toString();
}
function fetchGroupToPlanProcessor({ config, variableDefinitions, fragments, operationName, assignedDeferLabels, }) {
    let counter = 0;
    return {
        onFetchGroup: (group) => group.toPlanNode(config, variableDefinitions, fragments, operationName ? `${operationName}__${toValidGraphQLName(group.subgraphName)}__${counter++}` : undefined),
        reduceParallel: (values) => flatWrapNodes('Parallel', values),
        reduceSequence: (values) => flatWrapNodes('Sequence', values),
        reduceDeferred: (deferInfo, value) => ({
            depends: [...deferInfo.dependencies].map((id) => ({ id })),
            label: (assignedDeferLabels === null || assignedDeferLabels === void 0 ? void 0 : assignedDeferLabels.has(deferInfo.label)) ? undefined : deferInfo.label,
            queryPath: (0, federation_internals_1.operationPathToStringPath)(deferInfo.path.full()),
            subselection: deferInfo.deferred.size === 0 ? sanitizeAndPrintSubselection(deferInfo.subselection) : undefined,
            node: value,
        }),
        reduceDefer: (main, subselection, deferredBlocks) => ({
            kind: 'Defer',
            primary: {
                subselection: sanitizeAndPrintSubselection(subselection),
                node: main,
            },
            deferred: deferredBlocks,
        }),
    };
}
function flatWrapNodes(kind, nodes) {
    const filteredNodes = nodes.filter((n) => !!n);
    if (filteredNodes.length === 0) {
        return undefined;
    }
    if (filteredNodes.length === 1) {
        return filteredNodes[0];
    }
    return {
        kind,
        nodes: filteredNodes.flatMap((n) => n.kind === kind ? n.nodes : [n]),
    };
}
function addTypenameFieldForAbstractTypesInNamedFragments(fragments) {
    const fragmentsMap = new Map();
    for (const fragment of fragments.definitions()) {
        const expandedSelectionSet = fragment.selectionSet.expandFragments();
        addTypenameFieldForAbstractTypes(expandedSelectionSet);
        const otherFragmentsUsages = new Map();
        fragment.collectUsedFragmentNames(otherFragmentsUsages);
        fragmentsMap.set(fragment.name, {
            original: fragment,
            expandedSelectionSet,
            dependentsOn: Array.from(otherFragmentsUsages.keys()),
        });
    }
    const optimizedFragments = new federation_internals_1.NamedFragments();
    while (fragmentsMap.size > 0) {
        for (const [name, info] of fragmentsMap) {
            if (info.dependentsOn.every((n) => optimizedFragments.has(n))) {
                const reoptimizedSelectionSet = info.expandedSelectionSet.optimize(optimizedFragments);
                optimizedFragments.add(info.original.withUpdatedSelectionSet(reoptimizedSelectionSet));
                fragmentsMap.delete(name);
            }
        }
    }
    return optimizedFragments;
}
function addSelectionOrSelectionSet(selectionSet, toAdd) {
    if (toAdd instanceof federation_internals_1.SelectionSet) {
        selectionSet.mergeIn(toAdd);
    }
    else {
        selectionSet.add(toAdd);
    }
}
function removeRedundantFragmentsOfSet(selectionSet, type, unneededDirectives) {
    let newSet = undefined;
    const selections = selectionSet.selections();
    for (let i = 0; i < selections.length; i++) {
        const selection = selections[i];
        const updated = removeRedundantFragments(selection, type, unneededDirectives);
        if (newSet) {
            addSelectionOrSelectionSet(newSet, updated);
        }
        else if (selection !== updated) {
            newSet = new federation_internals_1.SelectionSet(type);
            for (let j = 0; j < i; j++) {
                newSet.add(selections[j]);
            }
            addSelectionOrSelectionSet(newSet, updated);
        }
    }
    return newSet ? newSet : selectionSet;
}
function removeRedundantFragments(selection, type, unneededDirectives) {
    if (selection.kind !== 'FragmentSelection') {
        return selection;
    }
    const fragment = selection.element();
    const fragmentType = fragment.typeCondition;
    if (!fragmentType) {
        return selection;
    }
    let neededDirectives = [];
    if (fragment.appliedDirectives.length > 0) {
        neededDirectives = (0, federation_internals_1.directiveApplicationsSubstraction)(fragment.appliedDirectives, unneededDirectives);
    }
    if ((0, federation_internals_1.sameType)(type, fragmentType) && neededDirectives.length === 0) {
        return removeRedundantFragmentsOfSet(selection.selectionSet, type, unneededDirectives);
    }
    else if (neededDirectives.length === fragment.appliedDirectives.length) {
        return selection;
    }
    else {
        const updatedFragment = new federation_internals_1.FragmentElement(type, fragment.typeCondition);
        neededDirectives.forEach((d) => updatedFragment.applyDirective(d.definition, d.arguments()));
        return (0, federation_internals_1.selectionSetOfElement)(updatedFragment, selection.selectionSet);
    }
}
function schemaRootKindToOperationKind(operation) {
    switch (operation) {
        case "query": return graphql_1.OperationTypeNode.QUERY;
        case "mutation": return graphql_1.OperationTypeNode.MUTATION;
        case "subscription": return graphql_1.OperationTypeNode.SUBSCRIPTION;
    }
}
function findAndRemoveInPlace(predicate, array) {
    const idx = array.findIndex((v) => predicate(v));
    if (idx >= 0) {
        array.splice(idx, 1);
    }
    return idx;
}
function sameMergeAt(m1, m2) {
    if (!m1) {
        return !m2;
    }
    if (!m2) {
        return false;
    }
    return (0, federation_internals_1.arrayEquals)(m1, m2);
}
function concatPathsInParents(first, second) {
    return first && second ? (0, federation_internals_1.concatOperationPaths)(first, second) : undefined;
}
function samePathsInParents(first, second) {
    if (!first) {
        return !second;
    }
    return !!second && (0, federation_internals_1.sameOperationPaths)(first, second);
}
function computeRootFetchGroups(dependencyGraph, pathTree, rootKind) {
    for (const [edge, _trigger, _conditions, child] of pathTree.childElements()) {
        (0, federation_internals_1.assert)(edge !== null, `The root edge should not be null`);
        const subgraphName = edge.tail.source;
        const rootType = edge.tail.type;
        const group = dependencyGraph.getOrCreateRootFetchGroup({ subgraphName, rootKind, parentType: rootType });
        computeGroupsForTree(dependencyGraph, child, group, GroupPath.empty(), emptyDeferContext);
    }
    return dependencyGraph;
}
function computeNonRootFetchGroups(dependencyGraph, pathTree, rootKind) {
    const subgraphName = pathTree.vertex.source;
    const rootType = pathTree.vertex.type;
    (0, federation_internals_1.assert)((0, federation_internals_1.isCompositeType)(rootType), () => `Should not have condition on non-selectable type ${rootType}`);
    const group = dependencyGraph.getOrCreateRootFetchGroup({ subgraphName, rootKind, parentType: rootType });
    computeGroupsForTree(dependencyGraph, pathTree, group, GroupPath.empty(), emptyDeferContext);
    return dependencyGraph;
}
function wrapEntitySelection(path, type, selections, context) {
    const typeCast = new federation_internals_1.FragmentElement(type, type.name);
    let updatedSelection = (0, federation_internals_1.selectionOfElement)(typeCast, selections);
    let newGroupContext = [typeCast];
    if (context.conditionals.length === 0) {
        return { updatedSelection, newPath: path.forNewKeyFetch(newGroupContext) };
    }
    const schema = type.schema();
    const [name0, ifs0] = context.conditionals[0];
    typeCast.applyDirective(schema.directive(name0), { 'if': ifs0 });
    for (let i = 1; i < context.conditionals.length; i++) {
        const [name, ifs] = context.conditionals[i];
        const fragment = new federation_internals_1.FragmentElement(type, type.name);
        fragment.applyDirective(schema.directive(name), { 'if': ifs });
        updatedSelection = (0, federation_internals_1.selectionOfElement)(fragment, (0, federation_internals_1.selectionSetOf)(type, updatedSelection));
        newGroupContext = [fragment].concat(newGroupContext);
    }
    return { updatedSelection, newPath: path.forNewKeyFetch(newGroupContext) };
}
function extractPathInParentForKeyFetch(type, path) {
    var _a;
    const inGroup = path.inGroup();
    const lastElement = inGroup[inGroup.length - 1];
    return (lastElement && lastElement.kind === 'FragmentElement' && ((_a = lastElement.typeCondition) === null || _a === void 0 ? void 0 : _a.name) === type.name)
        ? inGroup.slice(0, inGroup.length - 1)
        : inGroup;
}
function maybeSubstratPathPrefix(basePath, maybePrefix) {
    if (maybePrefix.length <= basePath.length && (0, federation_internals_1.sameOperationPaths)(maybePrefix, basePath.slice(0, maybePrefix.length))) {
        return basePath.slice(maybePrefix.length);
    }
    return undefined;
}
function computeGroupsForTree(dependencyGraph, pathTree, startGroup, initialGroupPath, initialDeferContext, initialContext = query_graphs_1.emptyContext) {
    const stack = [{
            tree: pathTree,
            group: startGroup,
            path: initialGroupPath,
            context: initialContext,
            deferContext: initialDeferContext,
        }];
    const createdGroups = [];
    while (stack.length > 0) {
        const { tree, group, path, context, deferContext } = stack.pop();
        if (tree.isLeaf()) {
            group.addSelection(path.inGroup());
            dependencyGraph.deferTracking.updateSubselection(deferContext);
        }
        else {
            for (const [edge, operation, conditions, child] of tree.childElements(true)) {
                if ((0, query_graphs_1.isPathContext)(operation)) {
                    const newContext = operation;
                    (0, federation_internals_1.assert)(edge !== null, () => `Unexpected 'null' edge with no trigger at ${path}`);
                    if (edge.transition.kind === 'KeyResolution') {
                        (0, federation_internals_1.assert)(conditions, () => `Key edge ${edge} should have some conditions paths`);
                        const conditionsGroups = computeGroupsForTree(dependencyGraph, conditions, group, path, deferContextForConditions(deferContext));
                        createdGroups.push(...conditionsGroups);
                        const type = edge.tail.type;
                        const pathInParent = extractPathInParentForKeyFetch(type, path);
                        const updatedDeferContext = deferContextAfterSubgraphJump(deferContext);
                        const newGroup = dependencyGraph.getOrCreateKeyFetchGroup({
                            subgraphName: edge.tail.source,
                            mergeAt: path.inResponse(),
                            parent: { group, path: pathInParent },
                            conditionsGroups,
                            deferRef: updatedDeferContext.activeDeferRef,
                        });
                        createdGroups.push(newGroup);
                        newGroup.addParents(conditionsGroups.map((conditionGroup) => {
                            const conditionGroupParents = conditionGroup.parents();
                            let path = undefined;
                            if (conditionGroupParents.length === 1 && conditionGroupParents[0].group === group && conditionGroupParents[0].path) {
                                path = maybeSubstratPathPrefix(conditionGroupParents[0].path, pathInParent);
                            }
                            return { group: conditionGroup, path };
                        }));
                        const inputSelections = newCompositeTypeSelectionSet(type);
                        inputSelections.mergeIn(edge.conditions);
                        const { updatedSelection, newPath } = wrapEntitySelection(path, type, inputSelections, newContext);
                        newGroup.addInputs(updatedSelection);
                        group.addSelection(path.inGroup().concat(new federation_internals_1.Field(edge.head.type.typenameField())));
                        stack.push({
                            tree: child,
                            group: newGroup,
                            path: newPath,
                            context: newContext,
                            deferContext: updatedDeferContext,
                        });
                    }
                    else {
                        (0, federation_internals_1.assert)(edge.transition.kind === 'RootTypeResolution', () => `Unexpected non-collecting edge ${edge}`);
                        const rootKind = edge.transition.rootKind;
                        (0, federation_internals_1.assert)(!conditions, () => `Root type resolution edge ${edge} should not have conditions`);
                        (0, federation_internals_1.assert)((0, federation_internals_1.isObjectType)(edge.head.type) && (0, federation_internals_1.isObjectType)(edge.tail.type), () => `Expected an objects for the vertices of ${edge}`);
                        const type = edge.tail.type;
                        (0, federation_internals_1.assert)(type === type.schema().schemaDefinition.rootType(rootKind), () => `Expected ${type} to be the root ${rootKind} type, but that is ${type.schema().schemaDefinition.rootType(rootKind)}`);
                        if (path.inGroup().length > 0) {
                            group.addSelection(path.inGroup().concat(new federation_internals_1.Field(edge.head.type.typenameField())));
                        }
                        const updatedDeferContext = deferContextAfterSubgraphJump(deferContext);
                        const newGroup = dependencyGraph.newRootTypeFetchGroup({
                            subgraphName: edge.tail.source,
                            rootKind,
                            parentType: type,
                            mergeAt: path.inResponse(),
                            deferRef: updatedDeferContext.activeDeferRef,
                        });
                        newGroup.addParent({ group, path: path.inGroup() });
                        const { newPath } = wrapEntitySelection(path, type, undefined, newContext);
                        stack.push({
                            tree: child,
                            group: newGroup,
                            path: newPath,
                            context: newContext,
                            deferContext: updatedDeferContext,
                        });
                    }
                }
                else if (edge === null) {
                    const { updatedOperation, updatedDeferContext } = extractDeferFromOperation({
                        dependencyGraph,
                        operation,
                        deferContext,
                        path,
                    });
                    let newPath = path;
                    if (updatedOperation && updatedOperation.appliedDirectives.length > 0) {
                        newPath = path.add(updatedOperation);
                    }
                    stack.push({
                        tree: child,
                        group,
                        path: newPath,
                        context,
                        deferContext: updatedDeferContext,
                    });
                }
                else {
                    (0, federation_internals_1.assert)(edge.head.source === edge.tail.source, () => `Collecting edge ${edge} for ${operation} should not change the underlying subgraph`);
                    const typenameAttachment = operation.getAttachement(SIBLING_TYPENAME_KEY);
                    if (typenameAttachment !== undefined) {
                        const alias = typenameAttachment === '' ? undefined : typenameAttachment;
                        const typenameField = new federation_internals_1.Field(operation.parentType.typenameField(), {}, new federation_internals_1.VariableDefinitions(), alias);
                        group.addSelection(path.inGroup().concat(typenameField));
                        dependencyGraph.deferTracking.updateSubselection({
                            ...deferContext,
                            pathToDeferParent: deferContext.pathToDeferParent.concat(typenameField),
                        });
                    }
                    const { updatedOperation, updatedDeferContext } = extractDeferFromOperation({
                        dependencyGraph,
                        operation,
                        deferContext,
                        path,
                    });
                    (0, federation_internals_1.assert)(updatedOperation, `Extracting @defer from ${operation} should not have resulted in no operation`);
                    let updated = {
                        tree: child,
                        group,
                        path,
                        context,
                        deferContext: updatedDeferContext
                    };
                    if (conditions) {
                        const requireResult = handleRequires(dependencyGraph, edge, conditions, group, path, context, updatedDeferContext);
                        updated.group = requireResult.group;
                        updated.path = requireResult.path;
                        createdGroups.push(...requireResult.createdGroups);
                    }
                    updated.path = updated.path.add(updatedOperation);
                    stack.push(updated);
                }
            }
        }
    }
    return createdGroups;
}
function extractDeferFromOperation({ dependencyGraph, operation, deferContext, path, }) {
    const deferArgs = operation.deferDirectiveArgs();
    if (!deferArgs) {
        return {
            updatedOperation: operation,
            updatedDeferContext: {
                ...deferContext,
                pathToDeferParent: deferContext.pathToDeferParent.concat(operation),
            }
        };
    }
    (0, federation_internals_1.assert)(deferArgs.label, 'All defers should have a lalel at this point');
    const updatedDeferRef = deferArgs.label;
    const updatedOperation = operation.withoutDefer();
    const updatedPathToDeferParent = updatedOperation ? [updatedOperation] : [];
    dependencyGraph.deferTracking.registerDefer({
        deferContext,
        deferArgs,
        path,
        parentType: operation.parentType,
    });
    return {
        updatedOperation,
        updatedDeferContext: {
            ...deferContext,
            currentDeferRef: updatedDeferRef,
            pathToDeferParent: updatedPathToDeferParent,
        },
    };
}
function addTypenameFieldForAbstractTypes(selectionSet) {
    for (const selection of selectionSet.selections()) {
        if (selection.kind == 'FieldSelection') {
            const fieldBaseType = (0, federation_internals_1.baseType)(selection.field.definition.type);
            if ((0, federation_internals_1.isAbstractType)(fieldBaseType)) {
                selection.selectionSet.add(new federation_internals_1.FieldSelection(new federation_internals_1.Field(fieldBaseType.typenameField())));
            }
            if (selection.selectionSet) {
                addTypenameFieldForAbstractTypes(selection.selectionSet);
            }
        }
        else {
            addTypenameFieldForAbstractTypes(selection.selectionSet);
        }
    }
}
function withoutTypename(selectionSet) {
    return selectionSet.filter((selection) => selection.kind !== 'FieldSelection' || selection.element().name === '__typename');
}
function pathHasOnlyFragments(path) {
    return path.every((element) => element.kind === 'FragmentElement');
}
function handleRequires(dependencyGraph, edge, requiresConditions, group, path, context, deferContext) {
    const entityType = edge.head.type;
    dependencyGraph.reduce();
    const parents = group.parents();
    if (parents.length === 1 && pathHasOnlyFragments(path.inGroup())) {
        const parent = parents[0];
        const originalInputs = group.clonedInputs();
        const newGroup = dependencyGraph.newKeyFetchGroup({ subgraphName: group.subgraphName, mergeAt: group.mergeAt, deferRef: group.deferRef });
        newGroup.addParent(parent);
        newGroup.addInputs(originalInputs.forRead());
        const createdGroups = computeGroupsForTree(dependencyGraph, requiresConditions, newGroup, path, deferContextForConditions(deferContext));
        if (createdGroups.length == 0) {
            (0, federation_internals_1.assert)(group.canMergeSiblingIn(newGroup), () => `We should be able to merge ${newGroup} into ${group} by construction`);
            group.mergeSiblingIn(newGroup);
            return { group, path, createdGroups: [] };
        }
        const newGroupIsUnneeded = newGroup.inputs.contains(withoutTypename(newGroup.selection)) && parent.path;
        const unmergedGroups = [];
        if (newGroupIsUnneeded) {
            parent.group.mergeChildIn(newGroup);
            for (const created of createdGroups) {
                if (created.subgraphName === parent.group.subgraphName && parent.group.canMergeChildIn(created)) {
                    parent.group.mergeChildIn(created);
                }
                else {
                    unmergedGroups.push(created);
                    let currentParent = parent;
                    while (currentParent
                        && !currentParent.group.isTopLevel
                        && created.isChildOfWithArtificialDependency(currentParent.group)) {
                        currentParent.group.removeChild(created);
                        const grandParents = currentParent.group.parents();
                        (0, federation_internals_1.assert)(grandParents.length > 0, `${currentParent.group} is not top-level, so it should have parents`);
                        for (const grandParent of grandParents) {
                            created.addParent({
                                group: grandParent.group,
                                path: concatPathsInParents(grandParent.path, currentParent.path),
                            });
                        }
                        currentParent = grandParents.length === 1 ? grandParents[0] : undefined;
                    }
                }
            }
        }
        else {
            (0, federation_internals_1.assert)(group.canMergeSiblingIn(newGroup), () => `We should be able to merge ${newGroup} into ${group} by construction`);
            group.mergeSiblingIn(newGroup);
            if (parent.path) {
                for (const created of createdGroups) {
                    if (created.subgraphName === parent.group.subgraphName
                        && parent.group.canMergeGrandChildIn(created)
                        && sameMergeAt(created.mergeAt, group.mergeAt)
                        && group.inputs.contains(created.inputs)) {
                        parent.group.mergeGrandChildIn(created);
                    }
                    else {
                        unmergedGroups.push(created);
                    }
                }
            }
        }
        if (unmergedGroups.length == 0) {
            group.addInputs(inputsForRequire(dependencyGraph.federatedQueryGraph, path, entityType, edge, context, false).inputs);
            return { group, path, createdGroups: [] };
        }
        const postRequireGroup = dependencyGraph.newKeyFetchGroup({ subgraphName: group.subgraphName, mergeAt: group.mergeAt, deferRef: group.deferRef });
        postRequireGroup.addParents(unmergedGroups.map((group) => ({ group })));
        if (newGroupIsUnneeded) {
            postRequireGroup.addParent(parent);
        }
        else {
            postRequireGroup.addParent({ group, path: [] });
        }
        (0, federation_internals_1.assert)(parent.path, `Missing path-in-parent for @require on ${edge} with group ${group} and parent ${parent}`);
        const newPath = addPostRequireInputs(dependencyGraph, path.forParentOfGroup(parent.path), entityType, edge, context, parent.group, postRequireGroup);
        return {
            group: postRequireGroup,
            path: newPath,
            createdGroups: unmergedGroups.concat(postRequireGroup),
        };
    }
    else {
        const createdGroups = computeGroupsForTree(dependencyGraph, requiresConditions, group, path, deferContextForConditions(deferContext));
        if (createdGroups.length == 0) {
            return { group, path, createdGroups: [] };
        }
        const newGroup = dependencyGraph.newKeyFetchGroup({ subgraphName: group.subgraphName, mergeAt: path.inResponse() });
        newGroup.addParents(createdGroups.map((group) => ({ group })));
        const newPath = addPostRequireInputs(dependencyGraph, path, entityType, edge, context, group, newGroup);
        return { group: newGroup, path: newPath, createdGroups: createdGroups.concat(newGroup) };
    }
}
function addPostRequireInputs(dependencyGraph, requirePath, entityType, edge, context, preRequireGroup, postRequireGroup) {
    const { inputs, newPath, keyInputs } = inputsForRequire(dependencyGraph.federatedQueryGraph, requirePath, entityType, edge, context);
    postRequireGroup.addInputs(inputs);
    if (keyInputs) {
        preRequireGroup.addSelection(requirePath.inGroup(), (endOfPathSet) => {
            (0, federation_internals_1.assert)(endOfPathSet, () => `Merge path ${requirePath} ends on a non-selectable type`);
            endOfPathSet.addAll(keyInputs.selections());
        });
    }
    return newPath;
}
function newCompositeTypeSelectionSet(type) {
    const selectionSet = new federation_internals_1.SelectionSet(type);
    selectionSet.add(new federation_internals_1.FieldSelection(new federation_internals_1.Field(type.typenameField())));
    return selectionSet;
}
function inputsForRequire(graph, path, entityType, edge, context, includeKeyInputs = true) {
    const fullSelectionSet = newCompositeTypeSelectionSet(entityType);
    fullSelectionSet.mergeIn(edge.conditions);
    let keyInputs = undefined;
    if (includeKeyInputs) {
        const keyCondition = (0, query_graphs_1.getLocallySatisfiableKey)(graph, edge.head);
        (0, federation_internals_1.assert)(keyCondition, () => `Due to @require, validation should have required a key to be present for ${edge}`);
        fullSelectionSet.mergeIn(keyCondition);
        keyInputs = newCompositeTypeSelectionSet(entityType);
        keyInputs.mergeIn(keyCondition);
    }
    const { updatedSelection, newPath } = wrapEntitySelection(path, entityType, fullSelectionSet, context);
    return {
        inputs: updatedSelection,
        newPath,
        keyInputs,
    };
}
const representationsVariable = new federation_internals_1.Variable('representations');
function representationsVariableDefinition(schema) {
    const metadata = (0, federation_internals_1.federationMetadata)(schema);
    (0, federation_internals_1.assert)(metadata, 'Expected schema to be a federation subgraph');
    const representationsType = new federation_internals_1.NonNullType(new federation_internals_1.ListType(new federation_internals_1.NonNullType(metadata.anyType())));
    return new federation_internals_1.VariableDefinition(schema, representationsVariable, representationsType);
}
function operationForEntitiesFetch(subgraphSchema, selectionSet, allVariableDefinitions, operationName) {
    const variableDefinitions = new federation_internals_1.VariableDefinitions();
    variableDefinitions.add(representationsVariableDefinition(subgraphSchema));
    variableDefinitions.addAll(allVariableDefinitions.filter(selectionSet.usedVariables()));
    const queryType = subgraphSchema.schemaDefinition.rootType('query');
    (0, federation_internals_1.assert)(queryType, `Subgraphs should always have a query root (they should at least provides _entities)`);
    const entities = queryType.field(federation_internals_1.entitiesFieldName);
    (0, federation_internals_1.assert)(entities, `Subgraphs should always have the _entities field`);
    const entitiesCall = new federation_internals_1.SelectionSet(queryType);
    entitiesCall.add(new federation_internals_1.FieldSelection(new federation_internals_1.Field(entities, { representations: representationsVariable }, variableDefinitions), selectionSet));
    return new federation_internals_1.Operation('query', entitiesCall, variableDefinitions, operationName);
}
function operationForQueryFetch(rootKind, selectionSet, allVariableDefinitions, operationName) {
    return new federation_internals_1.Operation(rootKind, selectionSet, allVariableDefinitions.filter(selectionSet.usedVariables()), operationName);
}
//# sourceMappingURL=buildPlan.js.map